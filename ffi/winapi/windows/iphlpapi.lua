require( 'ffi/winapi/headers/windows' )
require( 'ffi/winapi/headers/ip' )
require( 'ffi/winapi/headers/sockets' )
local ffi = require( 'ffi' )
ffi.cdef [[
  WINAPI_ERROR_CODE       GetAdapterIndex(                   LPWSTR AdapterName, PULONG IfIndex);
  WINAPI_ERROR_CODE_ULONG GetAdaptersAddresses(              ADDRESS_FAMILY Family, WINAPI_GetAdaptersAddressesFlags Flags, PVOID Reserved, PIP_ADAPTER_ADDRESSES AdapterAddresses, PULONG SizePointer);
  WINAPI_ERROR_CODE       GetAdaptersInfo(                   PIP_ADAPTER_INFO pAdapterInfo, PULONG pOutBufLen);
  WINAPI_ERROR_CODE       GetPerAdapterInfo(                 ULONG IfIndex, PIP_PER_ADAPTER_INFO pPerAdapterInfo, PULONG pOutBufLen);
  WINAPI_ERROR_CODE       GetUniDirectionalAdapterInfo(      PIP_UNIDIRECTIONAL_ADAPTER_ADDRESS pIPIfInfo, PULONG dwOutBufLen);
  WINAPI_ERROR_CODE       CreateIpNetEntry(                  PMIB_IPNETROW pArpEntry);
  WINAPI_ERROR_CODE       CreateProxyArpEntry(               DWORD dwAddress, DWORD dwMask, DWORD dwIfIndex);
  WINAPI_ERROR_CODE       DeleteIpNetEntry(                  PMIB_IPNETROW pArpEntry);
  WINAPI_ERROR_CODE       DeleteProxyArpEntry(               DWORD dwAddress, DWORD dwMask, DWORD dwIfIndex);
  WINAPI_ERROR_CODE       FlushIpNetTable(                   DWORD dwIfIndex);
  WINAPI_ERROR_CODE       GetIpNetTable(                     PMIB_IPNETTABLE pIpNetTable, PULONG pdwSize, BOOL bOrder);
  WINAPI_ERROR_CODE       SendARP(                           IPAddr DestIP, IPAddr SrcIP, PULONG pMacAddr, PULONG PhyAddrLen);
  WINAPI_ERROR_CODE       SetIpNetEntry(                     PMIB_IPNETROW pArpEntry);
  NETIO_STATUS            ConvertInterfaceAliasToLuid(       WINAPI_WCHAR* InterfaceAlias, PNET_LUID InterfaceLuid);
  NETIO_STATUS            ConvertInterfaceGuidToLuid(        WINAPI_GUID* InterfaceGuid, PNET_LUID InterfaceLuid);
  NETIO_STATUS            ConvertInterfaceIndexToLuid(       NET_IFINDEX InterfaceIndex, PNET_LUID InterfaceLuid);
  NETIO_STATUS            ConvertInterfaceLuidToAlias(       WINAPI_NET_LUID* InterfaceLuid, PWSTR InterfaceAlias, SIZE_T Length);
  NETIO_STATUS            ConvertInterfaceLuidToGuid(        WINAPI_NET_LUID* InterfaceLuid, GUID* InterfaceGuid);
  NETIO_STATUS            ConvertInterfaceLuidToIndex(       WINAPI_NET_LUID* InterfaceLuid, PNET_IFINDEX InterfaceIndex);
  NETIO_STATUS            ConvertInterfaceLuidToNameA(       WINAPI_NET_LUID* InterfaceLuid, PSTR InterfaceName, SIZE_T Length);
  NETIO_STATUS            ConvertInterfaceLuidToNameW(       WINAPI_NET_LUID* InterfaceLuid, PWSTR InterfaceName, SIZE_T Length);
  NETIO_STATUS            ConvertInterfaceNameToLuidA(       WINAPI_CHAR* InterfaceName, PNET_LUID InterfaceLuid);
  NETIO_STATUS            ConvertInterfaceNameToLuidW(       WINAPI_WCHAR* InterfaceName, PNET_LUID InterfaceLuid);
  PCHAR                   if_indextoname(                    NET_IFINDEX InterfaceIndex, PCHAR InterfaceName);
  NET_IFINDEX             if_nametoindex(                    PCSTR InterfaceName);
  WINAPI_ERROR_CODE       GetFriendlyIfIndex(                DWORD IfIndex);
  WINAPI_ERROR_CODE       GetIfEntry(                        PMIB_IFROW pIfRow);
  NETIOAPI_API            GetIfEntry2(                       PMIB_IF_ROW2 Row);
  NETIOAPI_API            GetIfStackTable(                   PMIB_IFSTACK_TABLE* Table);
  WINAPI_ERROR_CODE       GetIfTable(                        PMIB_IFTABLE pIfTable, PULONG pdwSize, BOOL bOrder);
  NETIOAPI_API            GetIfTable2(                       PMIB_IF_TABLE2* Table);
  NETIOAPI_API            GetIfTable2Ex(                     MIB_IF_TABLE_LEVEL Level, PMIB_IF_TABLE2* Table);
  WINAPI_ERROR_CODE       GetInterfaceInfo(                  PIP_INTERFACE_INFO pIfTable, PULONG dwOutBufLen);
  NETIOAPI_API            GetInvertedIfStackTable(           PMIB_INVERTEDIFSTACK_TABLE* Table);
  NETIOAPI_API            GetIpInterfaceEntry(               PMIB_IPINTERFACE_ROW Row);
  NETIOAPI_API            GetIpInterfaceTable(               ADDRESS_FAMILY Family, PMIB_IPINTERFACE_TABLE* Table);
  WINAPI_ERROR_CODE       GetNumberOfInterfaces(             PDWORD pdwNumIf);
  VOID                    InitializeIpInterfaceEntry(        PMIB_IPINTERFACE_ROW Row);
  WINAPI_ERROR_CODE       SetIfEntry(                        PMIB_IFROW pIfRow);
  NETIOAPI_API            SetIpInterfaceEntry(               PMIB_IPINTERFACE_ROW Row);
  WINAPI_ERROR_CODE       GetIcmpStatistics(                 PMIB_ICMP pStats);
  WINAPI_ERROR_CODE       GetIpStatistics(                   PMIB_IPSTATS pStats);
  WINAPI_FILE_HANDLE      Icmp6CreateFile(                   );
  WINAPI_ERROR_CODE       Icmp6ParseReplies(                 LPVOID ReplyBuffer, DWORD ReplySize);
  WINAPI_ERROR_CODE       Icmp6SendEcho2(                    HANDLE IcmpHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, struct sockaddr_in6* SourceAddress, struct sockaddr_in6* DestinationAddress, LPVOID RequestData, WORD RequestSize, PIP_OPTION_INFORMATION RequestOptions, LPVOID ReplyBuffer, DWORD ReplySize, DWORD Timeout);
  WINAPI_ERROR_CODE       IcmpSendEcho2Ex(                   HANDLE IcmpHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, IPAddr SourceAddress, IPAddr DestinationAddress, LPVOID RequestData, WORD RequestSize, PIP_OPTION_INFORMATION RequestOptions, LPVOID ReplyBuffer, DWORD ReplySize, DWORD Timeout);
  WINAPI_ERROR_CODE       SetIpTTL(                          UINT nTTL);
  WINAPI_ERROR_CODE       AddIPAddress(                      IPAddr Address, IPMask IpMask, DWORD IfIndex, PULONG NTEContext, PULONG NTEInstance);
  NETIOAPI_API            CreateAnycastIpAddressEntry(       WINAPI_MIB_ANYCASTIPADDRESS_ROW* Row);
  NETIOAPI_API            CreateUnicastIpAddressEntry(       WINAPI_MIB_UNICASTIPADDRESS_ROW* Row);
  WINAPI_ERROR_CODE       DeleteIPAddress(                   ULONG NTEContext);
  NETIOAPI_API            DeleteAnycastIpAddressEntry(       WINAPI_MIB_ANYCASTIPADDRESS_ROW* Row);
  NETIOAPI_API            DeleteUnicastIpAddressEntry(       WINAPI_MIB_UNICASTIPADDRESS_ROW* Row);
  NETIOAPI_API            GetAnycastIpAddressEntry(          PMIB_ANYCASTIPADDRESS_ROW Row);
  NETIOAPI_API            GetAnycastIpAddressTable(          ADDRESS_FAMILY Family, PMIB_ANYCASTIPADDRESS_TABLE* Table);
  WINAPI_ERROR_CODE       GetIpAddrTable(                    PMIB_IPADDRTABLE pIpAddrTable, PULONG pdwSize, BOOL bOrder);
  NETIOAPI_API            GetMulticastIpAddressEntry(        PMIB_MULTICASTIPADDRESS_ROW Row);
  NETIOAPI_API            GetMulticastIpAddressTable(        ADDRESS_FAMILY Family, PMIB_MULTICASTIPADDRESS_TABLE* Table);
  NETIOAPI_API            GetUnicastIpAddressEntry(          PMIB_UNICASTIPADDRESS_ROW Row);
  NETIOAPI_API            GetUnicastIpAddressTable(          ADDRESS_FAMILY Family, PMIB_UNICASTIPADDRESS_TABLE* Table);
  VOID                    InitializeUnicastIpAddressEntry(   PMIB_UNICASTIPADDRESS_ROW Row);
  WINAPI_ERROR_CODE       IpReleaseAddress(                  PIP_ADAPTER_INDEX_MAP AdapterInfo);
  WINAPI_ERROR_CODE       IpRenewAddress(                    PIP_ADAPTER_INDEX_MAP AdapterInfo);
  NETIOAPI_API            NotifyStableUnicastIpAddressTable( ADDRESS_FAMILY Family, PMIB_UNICASTIPADDRESS_TABLE* Table, PSTABLE_UNICAST_IPADDRESS_TABLE_CALLBACK CallerCallback, PVOID CallerContext, HANDLE* NotificationHandle);
  NETIOAPI_API            SetUnicastIpAddressEntry(          WINAPI_MIB_UNICASTIPADDRESS_ROW* Row);
  NETIOAPI_API            CreateIpNetEntry2(                 WINAPI_MIB_IPNET_ROW2* Row);
  NETIOAPI_API            DeleteIpNetEntry2(                 WINAPI_MIB_IPNET_ROW2* Row);
  NETIOAPI_API            FlushIpNetTable2(                  ADDRESS_FAMILY Family, NET_IFINDEX InterfaceIndex);
  NETIOAPI_API            GetIpNetEntry2(                    PMIB_IPNET_ROW2 Row);
  NETIOAPI_API            GetIpNetTable2(                    ADDRESS_FAMILY Family, PMIB_IPNET_TABLE2* Table);
  NETIOAPI_API            ResolveIpNetEntry2(                PMIB_IPNET_ROW2 Row, WINAPI_SOCKADDR_INET* SourceAddress);
  WINAPI_ERROR_CODE_ULONG ResolveNeighbor(                   SOCKADDR* NetworkAddress, PVOID PhysicalAddress, PULONG PhysicalAddressLength);
  NETIOAPI_API            SetIpNetEntry2(                    PMIB_IPNET_ROW2 Row);
  NETIOAPI_API            FlushIpPathTable(                  ADDRESS_FAMILY Family);
  NETIOAPI_API            GetIpPathEntry(                    PMIB_IPPATH_ROW Row);
  NETIOAPI_API            GetIpPathTable(                    ADDRESS_FAMILY Family, MIB_IPPATH_TABLE* Table);
  WINAPI_ERROR_CODE       CreateIpForwardEntry(              PMIB_IPFORWARDROW pRoute);
  NETIOAPI_API            CreateIpForwardEntry2(             WINAPI_MIB_IPFORWARD_ROW2* Row);
  WINAPI_ERROR_CODE       DeleteIpForwardEntry(              PMIB_IPFORWARDROW pRoute);
  NETIOAPI_API            DeleteIpForwardEntry2(             WINAPI_MIB_IPFORWARD_ROW2* Row);
  WINAPI_ERROR_CODE       EnableRouter(                      HANDLE* pHandle, OVERLAPPED* pOverlapped);
  WINAPI_ERROR_CODE       GetBestInterface(                  IPAddr dwDestAddr, PDWORD pdwBestIfIndex);
  WINAPI_ERROR_CODE       GetBestInterfaceEx(                struct sockaddr* pDestAddr, PDWORD pdwBestIfIndex);
  WINAPI_ERROR_CODE       GetBestRoute(                      DWORD dwDestAddr, DWORD dwSourceAddr, PMIB_IPFORWARDROW pBestRoute);
  NETIOAPI_API            GetBestRoute2(                     NET_LUID* InterfaceLuid, NET_IFINDEX InterfaceIndex, WINAPI_SOCKADDR_INET* SourceAddress, WINAPI_SOCKADDR_INET* DestinationAddress, ULONG AddressSortOptions, PMIB_IPFORWARD_ROW2 BestRoute, SOCKADDR_INET* BestSourceAddress);
  NETIOAPI_API            GetIpForwardEntry2(                PMIB_IPFORWARD_ROW2 Row);
  WINAPI_ERROR_CODE       GetIpForwardTable(                 PMIB_IPFORWARDTABLE pIpForwardTable, PULONG pdwSize, BOOL bOrder);
  NETIOAPI_API            GetIpForwardTable2(                ADDRESS_FAMILY Family, PMIB_IPFORWARD_TABLE2* Table);
  BOOL                    GetRTTAndHopCount(                 IPAddr DestIpAddress, PULONG HopCount, ULONG MaxHops, PULONG RTT);
  VOID                    InitializeIpForwardEntry(          PMIB_IPFORWARD_ROW2 Row);
  WINAPI_ERROR_CODE       SetIpForwardEntry(                 PMIB_IPFORWARDROW pRoute);
  NETIOAPI_API            SetIpForwardEntry2(                WINAPI_MIB_IPFORWARD_ROW2* Route);
  WINAPI_ERROR_CODE       SetIpStatistics(                   PMIB_IPSTATS pIpStats);
  WINAPI_ERROR_CODE       SetIpStatisticsEx(                 PMIB_IPSTATS pIpStats, ULONG Family);
  WINAPI_ERROR_CODE       UnenableRouter(                    OVERLAPPED* pOverlapped, LPDWORD lpdwEnableCount);
  VOID                    FreeMibTable(                      PVOID Memory);
  NETIO_STATUS            ConvertIpv4MaskToLength(           ULONG Mask, PUINT8 MaskLength);
  NETIO_STATUS            ConvertLengthToIpv4Mask(           ULONG MaskLength, PULONG Mask);
  NETIOAPI_API            CreateSortedAddressPairs(          WINAPI_PSOCKADDR_IN6 SourceAddressList, ULONG SourceAddressCount, WINAPI_PSOCKADDR_IN6 DestinationAddressList, ULONG DestinationAddressCount, ULONG AddressSortOptions, PSOCKADDR_IN6_PAIR* SortedAddressPairList, ULONG* SortedAddressPairCount);
  WINAPI_ERROR_CODE       ParseNetworkString(                WINAPI_WCHAR* NetworkString, DWORD Types, PNET_ADDRESS_INFO AddressInfo, USHORT* PortNumber, BYTE* PrefixLength);
  WINAPI_ERROR_CODE       GetNetworkParams(                  PFIXED_INFO pFixedInfo, PULONG pOutBufLen);
  NETIOAPI_API            CancelMibChangeNotify2(            HANDLE NotificationHandle);
  WINAPI_ERROR_CODE       NotifyAddrChange(                  PHANDLE Handle, LPOVERLAPPED overlapped);
  NETIOAPI_API            NotifyIpInterfaceChange(           ADDRESS_FAMILY Family, PIPINTERFACE_CHANGE_CALLBACK Callback, PVOID CallerContext, BOOLEAN InitialNotification, HANDLE* NotificationHandle);
  WINAPI_ERROR_CODE       NotifyRouteChange(                 PHANDLE Handle, LPOVERLAPPED overlapped);
  NETIOAPI_API            NotifyRouteChange2(                ADDRESS_FAMILY Family, PIPFORWARD_CHANGE_CALLBACK Callback, PVOID CallerContext, BOOLEAN InitialNotification, HANDLE* NotificationHandle);
  NETIOAPI_API            NotifyUnicastIpAddressChange(      ADDRESS_FAMILY Family, PUNICAST_IPADDRESS_CHANGE_CALLBACK Callback, PVOID CallerContext, BOOLEAN InitialNotification, HANDLE* NotificationHandle);
  BOOL                    CancelSecurityHealthChangeNotify(  LPOVERLAPPED notifyOverlapped);
  WINAPI_ERROR_CODE       NotifySecurityHealthChange(        PHANDLE pHandle, LPOVERLAPPED pOverLapped, PULONG SecurityHealthFlags);
  NETIOAPI_API            GetTeredoPort(                     USHORT* Port);
  NETIOAPI_API            NotifyTeredoPortChange(            PTEREDO_PORT_CHANGE_CALLBACK Callback, PVOID CallerContext, BOOLEAN InitialNotification, HANDLE* NotificationHandle);
  WINAPI_ERROR_CODE       GetExtendedTcpTable(               PVOID pTcpTable, PDWORD pdwSize, BOOL bOrder, ADDRESS_FAMILY ulAf, TCP_TABLE_CLASS TableClass, ULONG Reserved);
  WINAPI_ERROR_CODE       GetExtendedUdpTable(               PVOID pUdpTable, PDWORD pdwSize, BOOL bOrder, ADDRESS_FAMILY ulAf, UDP_TABLE_CLASS TableClass, ULONG Reserved);
  WINAPI_ERROR_CODE       GetOwnerModuleFromTcp6Entry(       PMIB_TCP6ROW_OWNER_MODULE pTcpEntry, TCPIP_OWNER_MODULE_INFO_CLASS Class, PVOID Buffer, PDWORD pdwSize);
  WINAPI_ERROR_CODE       GetOwnerModuleFromTcpEntry(        PMIB_TCPROW_OWNER_MODULE pTcpEntry, TCPIP_OWNER_MODULE_INFO_CLASS Class, PVOID Buffer, PDWORD pdwSize);
  WINAPI_ERROR_CODE       GetOwnerModuleFromUdp6Entry(       PMIB_UDP6ROW_OWNER_MODULE pUdpEntry, TCPIP_OWNER_MODULE_INFO_CLASS Class, PVOID Buffer, PDWORD pdwSize);
  WINAPI_ERROR_CODE       GetOwnerModuleFromUdpEntry(        PMIB_UDPROW_OWNER_MODULE pUdpEntry, TCPIP_OWNER_MODULE_INFO_CLASS Class, PVOID Buffer, PDWORD pdwSize);
  WINAPI_ERROR_CODE_ULONG GetPerTcp6ConnectionEStats(        PMIB_TCP6ROW Row, TCP_ESTATS_TYPE EstatsType, PUCHAR Rw, ULONG RwVersion, ULONG RwSize, PUCHAR Ros, ULONG RosVersion, ULONG RosSize, PUCHAR Rod, ULONG RodVersion, ULONG RodSize);
  WINAPI_ERROR_CODE_ULONG GetPerTcpConnectionEStats(         PMIB_TCPROW Row, TCP_ESTATS_TYPE EstatsType, PUCHAR Rw, ULONG RwVersion, ULONG RwSize, PUCHAR Ros, ULONG RosVersion, ULONG RosSize, PUCHAR Rod, ULONG RodVersion, ULONG RodSize);
  WINAPI_ERROR_CODE       GetTcpStatistics(                  PMIB_TCPSTATS pStats);
  WINAPI_ERROR_CODE       GetTcpStatisticsEx(                PMIB_TCPSTATS pStats, ADDRESS_FAMILY dwFamily);
  WINAPI_ERROR_CODE_ULONG GetTcp6Table(                      PMIB_TCP6TABLE TcpTable, PULONG SizePointer, BOOL Order);
  WINAPI_ERROR_CODE_ULONG GetTcp6Table2(                     PMIB_TCP6TABLE2 TcpTable, PULONG SizePointer, BOOL Order);
  WINAPI_ERROR_CODE       GetTcpTable(                       PMIB_TCPTABLE pTcpTable, PDWORD pdwSize, BOOL bOrder);
  WINAPI_ERROR_CODE_ULONG GetTcpTable2(                      PMIB_TCPTABLE2 TcpTable, PULONG SizePointer, BOOL Order);
  WINAPI_ERROR_CODE_ULONG SetPerTcp6ConnectionEStats(        PMIB_TCP6ROW Row, TCP_ESTATS_TYPE EstatsType, PUCHAR Rw, ULONG RwVersion, ULONG RwSize, ULONG Offset);
  WINAPI_ERROR_CODE_ULONG SetPerTcpConnectionEStats(         PMIB_TCP6ROW Row, TCP_ESTATS_TYPE EstatsType, PUCHAR Rw, ULONG RwVersion, ULONG RwSize, ULONG Offset);
  WINAPI_ERROR_CODE       SetTcpEntry(                       PMIB_TCPROW pTcpRow);
  WINAPI_ERROR_CODE_ULONG GetUdp6Table(                      PMIB_UDP6TABLE Udp6Table, PULONG SizePointer, BOOL Order);
  WINAPI_ERROR_CODE       GetUdpStatistics(                  PMIB_UDPSTATS pStats);
  WINAPI_ERROR_CODE       GetUdpStatisticsEx(                PMIB_UDPSTATS pStats, ADDRESS_FAMILY dwFamily);
  WINAPI_ERROR_CODE       GetUdpTable(                       PMIB_UDPTABLE pUdpTable, PDWORD pdwSize, BOOL bOrder);
  WINAPI_ERROR_CODE       AllocateAndGetTcpExTableFromStack( PVOID* ppTcpTable, BOOL bOrder, HANDLE hHeap, DWORD dwFlags, ADDRESS_FAMILY dwFamily);
  WINAPI_ERROR_CODE       AllocateAndGetUdpExTableFromStack( PVOID* ppUDPTable, BOOL bOrder, HANDLE hHeap, DWORD dwFlags, ADDRESS_FAMILY dwFamily);
  BOOL                    IcmpCloseHandle(                   HANDLE IcmpHandle);
  WINAPI_FILE_HANDLE      IcmpCreateFile(                    );
  DWORD                   IcmpParseReplies(                  LPVOID ReplyBuffer, DWORD ReplySize);
  WINAPI_ERROR_CODE       IcmpSendEcho(                      HANDLE IcmpHandle, IPAddr DestinationAddress, LPVOID RequestData, WORD RequestSize, PIP_OPTION_INFORMATION RequestOptions, LPVOID ReplyBuffer, DWORD ReplySize, DWORD Timeout);
  WINAPI_ERROR_CODE       IcmpSendEcho2(                     HANDLE IcmpHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, IPAddr DestinationAddress, LPVOID RequestData, WORD RequestSize, PIP_OPTION_INFORMATION RequestOptions, LPVOID ReplyBuffer, DWORD ReplySize, DWORD Timeout);
]]
return ffi.load( 'Iphlpapi.dll' )

require( "ffi/winapi/headers/windows" )
require( "ffi/winapi/headers/processes" )
require( "ffi/winapi/headers/native" )
require( "ffi/winapi/headers/gdi" )
require( "ffi/winapi/headers/ioctl" )
require( "ffi/winapi/headers/registry" )
local ffi = require( "ffi" )
ffi.cdef [[
  BOOL                         CheckRemoteDebuggerPresent(              WINAPI_ProcessHandle hProcess, PBOOL pbDebuggerPresent);
  BOOL                         ContinueDebugEvent(                      DWORD dwProcessId, DWORD dwThreadId, WINAPI_ContinueStatusFlag dwContinueStatus);
  BOOL                         CopyExtendedContext(                     PCONTEXT_EX Destination, DWORD ContextFlags, PCONTEXT_EX Source);
  BOOL                         DebugActiveProcess(                      DWORD dwProcessId);
  BOOL                         DebugActiveProcessStop(                  DWORD dwProcessId);
  VOID                         DebugBreak(                              );
  BOOL                         DebugBreakProcess(                       HANDLE Process);
  BOOL                         DebugSetProcessKillOnExit(               BOOL KillOnExit);
  VOID                         FatalExit(                               int ExitCode);
  BOOL                         FlushInstructionCache(                   WINAPI_ProcessHandle hProcess, LPCVOID lpBaseAddress, SIZE_T dwSize);
  DWORD64                      GetEnabledExtendedFeatures(              DWORD64 FeatureMask);
  BOOL                         GetExtendedContextLength(                DWORD ContextFlags, PDWORD ContextLength);
  DWORD64                      GetExtendedFeaturesMask(                 PCONTEXT_EX ContextEx);
  BOOL                         GetThreadContext(                        WINAPI_ThreadHandle hThread, LPCONTEXT lpContext);
  BOOL                         GetThreadSelectorEntry(                  WINAPI_ThreadHandle hThread, DWORD dwSelector, LPLDT_ENTRY lpSelectorEntry);
  BOOL                         InitializeExtendedContext(               PVOID Context, DWORD ContextFlags, PCONTEXT_EX* ContextEx);
  BOOL                         IsDebuggerPresent(                       );
  PVOID                        LocateExtendedFeature(                   PCONTEXT_EX ContextEx, DWORD FeatureId, PDWORD Length);
  PCONTEXT                     LocateLegacyContext(                     PCONTEXT_EX ContextEx, PDWORD Length);
  void                         OutputDebugString(                       LPCTSTR lpOutputString);
  BOOL                         ReadProcessMemory(                       WINAPI_ProcessHandle hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T* lpNumberOfBytesRead);
  VOID                         SetExtendedFeaturesMask(                 PCONTEXT_EX ContextEx, DWORD64 FeatureMask);
  BOOL                         SetThreadContext(                        WINAPI_ThreadHandle hThread, CONTEXT* lpContext);
  BOOL                         WaitForDebugEvent(                       LPDEBUG_EVENT lpDebugEvent, WINAPI_WaitTimeout dwMilliseconds);
  BOOL                         Wow64GetThreadContext(                   WINAPI_ThreadHandle hThread, PWOW64_CONTEXT lpContext);
  BOOL                         Wow64GetThreadSelectorEntry(             WINAPI_ThreadHandle hThread, DWORD dwSelector, PWOW64_LDT_ENTRY lpSelectorEntry);
  BOOL                         Wow64SetThreadContext(                   WINAPI_ThreadHandle hThread, CONST WOW64_CONTEXT* lpContext);
  BOOL                         WriteProcessMemory(                      WINAPI_ProcessHandle hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T* lpNumberOfBytesWritten);
  BOOL                         DisableThreadLibraryCalls(               HMODULE hModule);
  BOOL                         FreeLibrary(                             HMODULE hModule);
  VOID                         FreeLibraryAndExitThread(                HMODULE hModule, DWORD dwExitCode);
  DWORD                        GetDllDirectory(                         DWORD nBufferLength, LPTSTR lpBuffer);
  DWORD                        GetModuleFileName(                       HMODULE hModule, LPTSTR lpFilename, DWORD nSize);
  HMODULE                      GetModuleHandle(                         LPCTSTR lpModuleName);
  BOOL                         GetModuleHandleEx(                       WINAPI_GetModuleHandleExFlags dwFlags, LPCTSTR lpModuleName, HMODULE* phModule);
  FARPROC                      GetProcAddress(                          HMODULE hModule, LPCSTR lpProcName);
  HMODULE                      LoadLibrary(                             LPCTSTR lpFileName);
  HMODULE                      LoadLibraryEx(                           LPCTSTR lpFileName, HANDLE hFile, WINAPI_LoadLibraryExFlags dwFlags);
  DWORD                        LoadModule(                              LPCSTR lpModuleName, LPVOID lpParameterBlock);
  BOOL                         SetDllDirectory(                         LPCTSTR lpPathName);
  DLL_DIRECTORY_COOKIE         AddDllDirectory(                         PCWSTR NewDirectory);
  BOOL                         RemoveDllDirectory(                      DLL_DIRECTORY_COOKIE Cookie);
  BOOL                         SetDefaultDllDirectories(                WINAPI_LOAD_LIBRARY_SEARCH_FLAGS DirectoryFlags);
  WINAPI_FILE_HANDLE           CreateToolhelp32Snapshot(                WINAPI_CreateToolhelp32SnapshotFlags dwFlags, DWORD th32ProcessID);
  BOOL                         Heap32First(                             LPHEAPENTRY32 lphe, DWORD th32ProcessID, ULONG_PTR th32HeapID);
  BOOL                         Heap32ListFirst(                         HANDLE hSnapshot, LPHEAPLIST32 lphl);
  BOOL                         Heap32ListNext(                          HANDLE hSnapshot, LPHEAPLIST32 lphl);
  BOOL                         Heap32Next(                              LPHEAPENTRY32 lphe);
  BOOL                         Module32First(                           HANDLE hSnapshot, LPMODULEENTRY32 lpme);
  BOOL                         Module32Next(                            HANDLE hSnapshot, LPMODULEENTRY32 lpme);
  BOOL                         Process32First(                          HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
  BOOL                         Process32Next(                           HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
  BOOL                         Thread32First(                           HANDLE hSnapshot, LPTHREADENTRY32 lpte);
  BOOL                         Thread32Next(                            HANDLE hSnapshot, LPTHREADENTRY32 lpte);
  BOOL                         Toolhelp32ReadProcessMemory(             DWORD th32ProcessID, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T cbRead, SIZE_T lpNumberOfBytesRead);
  VOID                         ApplicationRecoveryFinished(             BOOL bSuccess);
  HRESULT                      ApplicationRecoveryInProgress(           PBOOL pbCanceled);
  HRESULT                      GetApplicationRecoveryCallback(          WINAPI_ProcessHandle hProcess, APPLICATION_RECOVERY_CALLBACK* pRecoveryCallback, PVOID* ppvParameter, DWORD dwPingInterval, DWORD dwFlags);
  HRESULT                      GetApplicationRestartSettings(           WINAPI_ProcessHandle hProcess, PWSTR pwzCommandline, PDWORD pcchSize, PDWORD pdwFlags);
  HRESULT                      RegisterApplicationRecoveryCallback(     APPLICATION_RECOVERY_CALLBACK pRecoveryCallback, PVOID pvParameter, DWORD dwPingInterval, WINAPI_ApplicationRestartFlags dwFlags);
  HRESULT                      RegisterApplicationRestart(              PCWSTR pwzCommandline, WINAPI_ApplicationRestartFlags dwFlags);
  HRESULT                      UnregisterApplicationRecoveryCallback(   );
  HRESULT                      UnregisterApplicationRestart(            );
  UINT                         GetPrivateProfileInt(                    LPCTSTR lpAppName, LPCTSTR lpKeyName, INT nDefault, LPCTSTR lpFileName);
  DWORD                        GetPrivateProfileSection(                LPCTSTR lpAppName, LPTSTR lpReturnedString, DWORD nSize, LPCTSTR lpFileName);
  DWORD                        GetPrivateProfileSectionNames(           LPTSTR lpszReturnBuffer, DWORD nSize, LPCTSTR lpFileName);
  DWORD                        GetPrivateProfileString(                 LPCTSTR lpAppName, LPCTSTR lpKeyName, LPCTSTR lpDefault, LPTSTR lpReturnedString, DWORD nSize, LPCTSTR lpFileName);
  BOOL                         GetPrivateProfileStruct(                 LPCTSTR lpszSection, LPCTSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCTSTR szFile);
  UINT                         GetProfileInt(                           LPCTSTR lpAppName, LPCTSTR lpKeyName, INT nDefault);
  DWORD                        GetProfileSection(                       LPCTSTR lpAppName, LPTSTR lpReturnedString, DWORD nSize);
  DWORD                        GetProfileString(                        LPCTSTR lpAppName, LPCTSTR lpKeyName, LPCTSTR lpDefault, LPTSTR lpReturnedString, DWORD nSize);
  BOOL                         WritePrivateProfileSection(              LPCTSTR lpAppName, LPCTSTR lpString, LPCTSTR lpFileName);
  BOOL                         WritePrivateProfileString(               LPCTSTR lpAppName, LPCTSTR lpKeyName, LPCTSTR lpString, LPCTSTR lpFileName);
  BOOL                         WritePrivateProfileStruct(               LPCTSTR lpszSection, LPCTSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCTSTR szFile);
  BOOL                         WriteProfileSection(                     LPCTSTR lpAppName, LPCTSTR lpString);
  BOOL                         WriteProfileString(                      LPCTSTR lpAppName, LPCTSTR lpKeyName, LPCTSTR lpString);
  HFILE                        _lopen(                                  LPCSTR lpPathName, int iReadWrite);
  HFILE                        _lcreat(                                 LPCSTR lpPathName, WINAPI_lcreatAttribute iAttribute);
  UINT                         _lread(                                  HFILE hFile, LPVOID lpBuffer, UINT uBytes);
  UINT                         _lwrite(                                 HFILE hFile, LPVOID lpBuffer, UINT uBytes);
  long                         _hread(                                  HFILE hFile, LPVOID lpBuffer, LONG lBytes);
  long                         _hwrite(                                 HFILE hFile, LPVOID lpBuffer, LONG lBytes);
  HFILE                        _lclose(                                 HFILE hFile);
  LONG                         _llseek(                                 HFILE hFile, LONG lOffset, WINAPI_SEEK_TYPE iOrigin);
  BOOL                         AreFileApisANSI(                         );
  BOOL                         CheckNameLegalDOS8Dot3(                  LPCTSTR lpName, LPSTR lpOemName, DWORD OemNameSize, PBOOL pbNameContainsSpaces, PBOOL pbNameLegal);
  BOOL                         CopyFile(                                LPCTSTR lpExistingFileName, LPCTSTR lpNewFileName, BOOL bFailIfExists);
  BOOL                         CopyFileEx(                              LPCTSTR lpExistingFileName, LPCTSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags);
  BOOL                         CopyFileTransacted(                      LPCTSTR lpExistingFileName, LPCTSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags, HANDLE hTransaction);
  WINAPI_FILE_HANDLE           CreateFile(                              LPCTSTR lpFileName, WINAPI_FILE_ACCESS_MASK dwDesiredAccess, WINAPI_FileShareMode dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, WINAPI_CreationDisposition dwCreationDisposition, WINAPI_FlagsAndAttributes dwFlagsAndAttributes, HANDLE hTemplateFile);
  WINAPI_FILE_HANDLE           CreateFileTransacted(                    LPCTSTR lpFileName, WINAPI_FILE_ACCESS_MASK dwDesiredAccess, WINAPI_FileShareMode dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, WINAPI_CreationDisposition dwCreationDisposition, WINAPI_FlagsAndAttributes dwFlagsAndAttributes, HANDLE hTemplateFile, HANDLE hTransaction, PUSHORT pusMiniVersion, PVOID pExtendedParameter);
  BOOL                         CreateHardLink(                          LPCTSTR lpFileName, LPCTSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
  BOOL                         CreateHardLinkTransacted(                LPCTSTR lpFileName, LPCTSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction);
  BOOLEAN                      CreateSymbolicLink(                      LPTSTR lpSymlinkFileName, LPTSTR lpTargetFileName, WINAPI_CreateSymbolicLinkFlags dwFlags);
  BOOLEAN                      CreateSymbolicLinkTransacted(            LPTSTR lpSymlinkFileName, LPTSTR lpTargetFileName, WINAPI_CreateSymbolicLinkFlags dwFlags, HANDLE hTransaction);
  BOOL                         DeleteFile(                              LPCTSTR lpFileName);
  BOOL                         DeleteFileTransacted(                    LPCTSTR lpFileName, HANDLE hTransaction);
  BOOL                         FindClose(                               HANDLE hFindFile);
  WINAPI_FILE_HANDLE           FindFirstFile(                           LPCTSTR lpFileName, LPWIN32_FIND_DATA lpFindFileData);
  WINAPI_FILE_HANDLE           FindFirstFileEx(                         LPCTSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, WINAPI_FindFirstFileExFlags dwAdditionalFlags);
  WINAPI_FILE_HANDLE           FindFirstFileNameTransactedW(            LPCWSTR lpFileName, DWORD dwFlags, LPDWORD StringLength, PWCHAR LinkName, HANDLE hTransaction);
  WINAPI_FILE_HANDLE           FindFirstFileNameW(                      LPCWSTR lpFileName, DWORD dwFlags, LPDWORD StringLength, PWCHAR LinkName);
  WINAPI_FILE_HANDLE           FindFirstFileTransacted(                 LPCTSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, WINAPI_FindFirstFileExFlags dwAdditionalFlags, HANDLE hTransaction);
  WINAPI_FILE_HANDLE           FindFirstStreamTransactedW(              LPCWSTR lpFileName, STREAM_INFO_LEVELS InfoLevel, LPVOID lpFindStreamData, DWORD dwFlags, HANDLE hTransaction);
  WINAPI_FILE_HANDLE           FindFirstStreamW(                        LPCWSTR lpFileName, STREAM_INFO_LEVELS InfoLevel, LPVOID lpFindStreamData, DWORD dwFlags);
  BOOL                         FindNextFile(                            HANDLE hFindFile, LPWIN32_FIND_DATA lpFindFileData);
  BOOL                         FindNextFileNameW(                       HANDLE hFindStream, LPDWORD StringLength, PWCHAR LinkName);
  BOOL                         FindNextStreamW(                         HANDLE hFindStream, LPVOID lpFindStreamData);
  BOOL                         GetBinaryType(                           LPCTSTR lpApplicationName, WINAPI_GetBinaryTypeResult* lpBinaryType);
  DWORD                        GetCompressedFileSize(                   LPCTSTR lpFileName, LPDWORD lpFileSizeHigh);
  DWORD                        GetCompressedFileSizeTransacted(         LPCTSTR lpFileName, LPDWORD lpFileSizeHigh, HANDLE hTransaction);
  WINAPI_FileAttributes        GetFileAttributes(                       LPCTSTR lpFileName);
  BOOL                         GetFileAttributesEx(                     LPCTSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation);
  BOOL                         GetFileAttributesTransacted(             LPCTSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation, HANDLE hTransaction);
  BOOL                         GetFileBandwidthReservation(             HANDLE hFile, LPDWORD lpPeriodMilliseconds, LPDWORD lpBytesPerPeriod, LPBOOL pDiscardable, LPDWORD lpTransferSize, LPDWORD lpNumOutstandingRequests);
  BOOL                         GetFileInformationByHandle(              HANDLE hFile, LPBY_HANDLE_FILE_INFORMATION lpFileInformation);
  BOOL                         GetFileInformationByHandleEx(            HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize);
  DWORD                        GetFileSize(                             HANDLE hFile, LPDWORD lpFileSizeHigh);
  BOOL                         GetFileSizeEx(                           HANDLE hFile, PLARGE_INTEGER lpFileSize);
  WINAPI_FileType              GetFileType(                             HANDLE hFile);
  DWORD                        GetFinalPathNameByHandle(                HANDLE hFile, LPTSTR lpszFilePath, DWORD cchFilePath, WINAPI_GetFinalPathNameByHandleFlags dwFlags);
  DWORD                        GetFullPathName(                         LPCTSTR lpFileName, DWORD nBufferLength, LPTSTR lpBuffer, LPTSTR* lpFilePart);
  DWORD                        GetFullPathNameTransacted(               LPCTSTR lpFileName, DWORD nBufferLength, LPTSTR lpBuffer, LPTSTR* lpFilePart, HANDLE hTransaction);
  DWORD                        GetLongPathName(                         LPCTSTR lpszShortPath, LPTSTR lpszLongPath, DWORD cchBuffer);
  DWORD                        GetLongPathNameTransacted(               LPCTSTR lpszShortPath, LPTSTR lpszLongPath, DWORD cchBuffer, HANDLE hTransaction);
  DWORD                        GetShortPathName(                        LPCTSTR lpszLongPath, LPTSTR lpszShortPath, DWORD cchBuffer);
  UINT                         GetTempFileName(                         LPCTSTR lpPathName, LPCTSTR lpPrefixString, UINT uUnique, LPTSTR lpTempFileName);
  DWORD                        GetTempPath(                             DWORD nBufferLength, LPTSTR lpBuffer);
  BOOL                         MoveFile(                                LPCTSTR lpExistingFileName, LPCTSTR lpNewFileName);
  BOOL                         MoveFileEx(                              LPCTSTR lpExistingFileName, LPCTSTR lpNewFileName, WINAPI_MoveFileFlags dwFlags);
  BOOL                         MoveFileTransacted(                      LPCTSTR lpExistingFileName, LPCTSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags, HANDLE hTransaction);
  BOOL                         MoveFileWithProgress(                    LPCTSTR lpExistingFileName, LPCTSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags);
  HFILE                        OpenFile(                                LPCSTR lpFileName, LPOFSTRUCT lpReOpenBuff, WINAPI_OpenFileFlags uStyle);
  WINAPI_FILE_HANDLE           OpenFileById(                            HANDLE hFile, LPFILE_ID_DESCRIPTOR lpFileID, WINAPI_FILE_ACCESS_MASK dwDesiredAccess, WINAPI_FileShareMode dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, WINAPI_FlagsAndAttributes dwFlags);
  WINAPI_FILE_HANDLE           ReOpenFile(                              HANDLE hOriginalFile, WINAPI_FILE_ACCESS_MASK dwDesiredAccess, WINAPI_FileShareMode dwShareMode, WINAPI_FlagsAndAttributes dwFlags);
  BOOL                         ReplaceFile(                             LPCTSTR lpReplacedFileName, LPCTSTR lpReplacementFileName, LPCTSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved);
  DWORD                        SearchPath(                              LPCTSTR lpPath, LPCTSTR lpFileName, LPCTSTR lpExtension, DWORD nBufferLength, LPTSTR lpBuffer, LPTSTR* lpFilePart);
  void                         SetFileApisToANSI(                       );
  void                         SetFileApisToOEM(                        );
  BOOL                         SetFileAttributes(                       LPCTSTR lpFileName, WINAPI_FileAttributes dwFileAttributes);
  BOOL                         SetFileAttributesTransacted(             LPCTSTR lpFileName, WINAPI_FileAttributes dwFileAttributes, HANDLE hTransaction);
  BOOL                         SetFileBandwidthReservation(             HANDLE hFile, DWORD nPeriodMilliseconds, DWORD nBytesPerPeriod, BOOL bDiscardable, LPDWORD lpTransferSize, LPDWORD lpNumOutstandingRequests);
  BOOL                         SetFileInformationByHandle(              HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize);
  BOOL                         SetFileShortName(                        HANDLE hFile, LPCTSTR lpShortName);
  BOOL                         SetFileValidData(                        HANDLE hFile, LONGLONG ValidDataLength);
  BOOL                         SetSearchPathMode(                       DWORD Flags);
  BOOL                         CancelIo(                                HANDLE hFile);
  BOOL                         CancelIoEx(                              HANDLE hFile, LPOVERLAPPED lpOverlapped);
  BOOL                         CancelSynchronousIo(                     WINAPI_ThreadHandle hThread);
  HANDLE                       CreateIoCompletionPort(                  HANDLE FileHandle, HANDLE ExistingCompletionPort, ULONG_PTR CompletionKey, DWORD NumberOfConcurrentThreads);
  BOOL                         FlushFileBuffers(                        HANDLE hFile);
  BOOL                         GetQueuedCompletionStatus(               HANDLE CompletionPort, LPDWORD lpNumberOfBytes, PULONG_PTR lpCompletionKey, LPOVERLAPPED* lpOverlapped, WINAPI_WaitTimeout dwMilliseconds);
  BOOL                         GetQueuedCompletionStatusEx(             HANDLE CompletionPort, LPOVERLAPPED_ENTRY lpCompletionPortEntries, ULONG ulCount, PULONG ulNumEntriesRemoved, WINAPI_WaitTimeout dwMilliseconds, BOOL fAlertable);
  BOOL                         LockFile(                                HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh);
  BOOL                         LockFileEx(                              HANDLE hFile, WINAPI_LockFileFlags dwFlags, DWORD dwReserved, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh, LPOVERLAPPED lpOverlapped);
  BOOL                         PostQueuedCompletionStatus(              HANDLE CompletionPort, DWORD dwNumberOfBytesTransferred, ULONG_PTR dwCompletionKey, LPOVERLAPPED lpOverlapped);
  BOOL                         ReadFile(                                HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
  BOOL                         ReadFileEx(                              HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);
  BOOL                         ReadFileScatter(                         HANDLE hFile, FILE_SEGMENT_ELEMENT[] aSegmentArray, DWORD nNumberOfBytesToRead, LPDWORD lpReserved, LPOVERLAPPED lpOverlapped);
  BOOL                         SetEndOfFile(                            HANDLE hFile);
  BOOL                         SetFileCompletionNotificationModes(      HANDLE FileHandle, UCHAR Flags);
  BOOL                         SetFileIoOverlappedRange(                HANDLE FileHandle, PUCHAR OverlappedRangeStart, ULONG Length);
  DWORD                        SetFilePointer(                          HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, WINAPI_MoveMethodEnum dwMoveMethod);
  BOOL                         SetFilePointerEx(                        HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, WINAPI_MoveMethodEnum dwMoveMethod);
  BOOL                         UnlockFile(                              HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh);
  BOOL                         UnlockFileEx(                            HANDLE hFile, DWORD dwReserved, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh, LPOVERLAPPED lpOverlapped);
  BOOL                         WriteFile(                               HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
  BOOL                         WriteFileEx(                             HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);
  BOOL                         WriteFileGather(                         HANDLE hFile, FILE_SEGMENT_ELEMENT[] aSegmentArray, DWORD nNumberOfBytesToWrite, LPDWORD lpReserved, LPOVERLAPPED lpOverlapped);
  BOOL                         Wow64DisableWow64FsRedirection(          PVOID* OldValue);
  BOOLEAN                      Wow64EnableWow64FsRedirection(           BOOLEAN Wow64FsEnableRedirection);
  BOOL                         Wow64RevertWow64FsRedirection(           PVOID OldValue);
  BOOL                         AddSecureMemoryCacheCallback(            PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack);
  HANDLE                       CreateMemoryResourceNotification(        MEMORY_RESOURCE_NOTIFICATION_TYPE NotificationType);
  SIZE_T                       GetLargePageMinimum(                     );
  BOOL                         GetPhysicallyInstalledSystemMemory(      PULONGLONG TotalMemoryInKilobytes);
  BOOL                         GetSystemFileCacheSize(                  PSIZE_T lpMinimumFileCacheSize, PSIZE_T lpMaximumFileCacheSize, PDWORD lpFlags);
  UINT                         GetWriteWatch(                           DWORD dwFlags, PVOID lpBaseAddress, SIZE_T dwRegionSize, PVOID* lpAddresses, PULONG_PTR lpdwCount, PULONG lpdwGranularity);
  BOOL                         GlobalMemoryStatusEx(                    LPMEMORYSTATUSEX lpBuffer);
  BOOL                         QueryMemoryResourceNotification(         HANDLE ResourceNotificationHandle, PBOOL ResourceState);
  BOOL                         RemoveSecureMemoryCacheCallback(         PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack);
  UINT                         ResetWriteWatch(                         LPVOID lpBaseAddress, SIZE_T dwRegionSize);
  BOOL                         SetSystemFileCacheSize(                  SIZE_T MinimumFileCacheSize, SIZE_T MaximumFileCacheSize, DWORD Flags);
  BOOL                         GetProcessDEPPolicy(                     WINAPI_ProcessHandle hProcess, LPDWORD lpFlags, PBOOL lpPermanent);
  DEP_SYSTEM_POLICY_TYPE       GetSystemDEPPolicy(                      );
  BOOL                         SetProcessDEPPolicy(                     DWORD dwFlags);
  HANDLE                       CreateFileMapping(                       WINAPI_FILE_HANDLE hFile, LPSECURITY_ATTRIBUTES lpAttributes, WINAPI_MemoryProtection flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCTSTR lpName);
  HANDLE                       CreateFileMappingNuma(                   WINAPI_FILE_HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, WINAPI_MemoryProtection flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCTSTR lpName, DWORD nndPreferred);
  BOOL                         FlushViewOfFile(                         LPCVOID lpBaseAddress, SIZE_T dwNumberOfBytesToFlush);
  LPVOID                       MapViewOfFile(                           HANDLE hFileMappingObject, WINAPI_MapAccessFlags dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap);
  LPVOID                       MapViewOfFileEx(                         HANDLE hFileMappingObject, WINAPI_MapAccessFlags dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress);
  LPVOID                       MapViewOfFileExNuma(                     HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress, DWORD nndPreferred);
  HANDLE                       OpenFileMapping(                         WINAPI_MapAccessFlags dwDesiredAccess, BOOL bInheritHandle, LPCTSTR lpName);
  BOOL                         UnmapViewOfFile(                         LPCVOID lpBaseAddress);
  BOOL                         AllocateUserPhysicalPages(               WINAPI_ProcessHandle hProcess, PULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);
  BOOL                         FreeUserPhysicalPages(                   WINAPI_ProcessHandle hProcess, PULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);
  BOOL                         MapUserPhysicalPages(                    PVOID lpAddress, ULONG_PTR NumberOfPages, PULONG_PTR UserPfnArray);
  BOOL                         MapUserPhysicalPagesScatter(             PVOID* VirtualAddresses, ULONG_PTR NumberOfPages, PULONG_PTR PageArray);
  HANDLE                       GetProcessHeap(                          );
  DWORD                        GetProcessHeaps(                         DWORD NumberOfHeaps, PHANDLE ProcessHeaps);
  LPVOID                       HeapAlloc(                               HANDLE hHeap, WINAPI_HEAP_FLAGS dwFlags, SIZE_T dwBytes);
  SIZE_T                       HeapCompact(                             HANDLE hHeap, WINAPI_HEAP_FLAGS dwFlags);
  HANDLE                       HeapCreate(                              WINAPI_HEAP_FLAGS flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize);
  BOOL                         HeapDestroy(                             HANDLE hHeap);
  BOOL                         HeapFree(                                HANDLE hHeap, WINAPI_HEAP_FLAGS dwFlags, LPVOID lpMem);
  BOOL                         HeapLock(                                HANDLE hHeap);
  BOOL                         HeapQueryInformation(                    HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength, PSIZE_T ReturnLength);
  LPVOID                       HeapReAlloc(                             HANDLE hHeap, WINAPI_HEAP_FLAGS dwFlags, LPVOID lpMem, SIZE_T dwBytes);
  BOOL                         HeapSetInformation(                      HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength);
  SIZE_T                       HeapSize(                                HANDLE hHeap, WINAPI_HEAP_FLAGS dwFlags, LPCVOID lpMem);
  BOOL                         HeapUnlock(                              HANDLE hHeap);
  BOOL                         HeapValidate(                            HANDLE hHeap, WINAPI_HEAP_FLAGS dwFlags, LPCVOID lpMem);
  BOOL                         HeapWalk(                                HANDLE hHeap, LPPROCESS_HEAP_ENTRY lpEntry);
  LPVOID                       VirtualAlloc(                            LPVOID lpAddress, SIZE_T dwSize, WINAPI_MemoryAllocationFlags flAllocationType, WINAPI_MemoryProtection flProtect);
  LPVOID                       VirtualAllocEx(                          WINAPI_ProcessHandle hProcess, LPVOID lpAddress, SIZE_T dwSize, WINAPI_MemoryAllocationFlags flAllocationType, WINAPI_MemoryProtection flProtect);
  LPVOID                       VirtualAllocExNuma(                      WINAPI_ProcessHandle hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, WINAPI_MemoryProtection flProtect, DWORD nndPreferred);
  BOOL                         VirtualFree(                             LPVOID lpAddress, SIZE_T dwSize, WINAPI_MemoryAllocationFlags dwFreeType);
  BOOL                         VirtualFreeEx(                           WINAPI_ProcessHandle hProcess, LPVOID lpAddress, SIZE_T dwSize, WINAPI_MemoryAllocationFlags dwFreeType);
  BOOL                         VirtualLock(                             LPVOID lpAddress, SIZE_T dwSize);
  BOOL                         VirtualProtect(                          LPVOID lpAddress, SIZE_T dwSize, WINAPI_MemoryProtection flNewProtect, WINAPI_MemoryProtection* lpflOldProtect);
  BOOL                         VirtualProtectEx(                        WINAPI_ProcessHandle hProcess, LPVOID lpAddress, SIZE_T dwSize, WINAPI_MemoryProtection flNewProtect, WINAPI_MemoryProtection* lpflOldProtect);
  SIZE_T                       VirtualQuery(                            LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength);
  SIZE_T                       VirtualQueryEx(                          WINAPI_ProcessHandle hProcess, LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength);
  BOOL                         VirtualUnlock(                           LPVOID lpAddress, SIZE_T dwSize);
  HGLOBAL                      GlobalAlloc(                             WINAPI_GlobalMemoryFlag uFlags, SIZE_T dwBytes);
  HLOCAL                       LocalAlloc(                              WINAPI_LocalMemoryFlag uFlags, SIZE_T uBytes);
  UINT                         GlobalFlags(                             HGLOBAL hMem);
  UINT                         LocalFlags(                              HLOCAL hMem);
  HGLOBAL                      GlobalFree(                              HGLOBAL hMem);
  HLOCAL                       LocalFree(                               HLOCAL hMem);
  HGLOBAL                      GlobalHandle(                            LPCVOID pMem);
  HLOCAL                       LocalHandle(                             LPCVOID pMem);
  LPVOID                       GlobalLock(                              HGLOBAL hMem);
  LPVOID                       LocalLock(                               HLOCAL hMem);
  HGLOBAL                      GlobalReAlloc(                           HGLOBAL hMem, SIZE_T dwBytes, WINAPI_GlobalMemoryFlag uFlags);
  HLOCAL                       LocalReAlloc(                            HLOCAL hMem, SIZE_T uBytes, WINAPI_LocalMemoryFlag uFlags);
  SIZE_T                       GlobalSize(                              HGLOBAL hMem);
  UINT                         LocalSize(                               HLOCAL hMem);
  BOOL                         GlobalUnlock(                            HGLOBAL hMem);
  BOOL                         LocalUnlock(                             HLOCAL hMem);
  BOOL                         IsBadCodePtr(                            FARPROC lpfn);
  BOOL                         IsBadReadPtr(                            VOID* lp, UINT_PTR ucb);
  BOOL                         IsBadStringPtr(                          LPCTSTR lpsz, UINT_PTR ucchMax);
  BOOL                         IsBadWritePtr(                           LPVOID lp, UINT_PTR ucb);
  void                         GlobalMemoryStatus(                      LPMEMORYSTATUS lpBuffer);
  BOOL                         CreateProcess(                           LPCTSTR lpApplicationName, LPTSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, WINAPI_CreateProcessFlags dwCreationFlags, LPVOID lpEnvironment, LPCTSTR lpCurrentDirectory, LPSTARTUPINFO lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
  VOID                         ExitProcess(                             UINT uExitCode);
  VOID                         FlushProcessWriteBuffers(                );
  BOOL                         FreeEnvironmentStrings(                  LPTCH lpszEnvironmentBlock);
  LPTSTR                       GetCommandLine(                          );
  WINAPI_ProcessHandle         GetCurrentProcess(                       );
  DWORD                        GetCurrentProcessId(                     );
  DWORD                        GetCurrentProcessorNumber(               );
  LPTCH                        GetEnvironmentStrings(                   );
  DWORD                        GetEnvironmentVariable(                  LPCTSTR lpName, LPTSTR lpBuffer, DWORD nSize);
  BOOL                         GetExitCodeProcess(                      WINAPI_ProcessHandle hProcess, LPDWORD lpExitCode);
  DWORD                        GetPriorityClass(                        WINAPI_ProcessHandle hProcess);
  BOOL                         GetProcessAffinityMask(                  WINAPI_ProcessHandle hProcess, PDWORD_PTR lpProcessAffinityMask, PDWORD_PTR lpSystemAffinityMask);
  BOOL                         GetProcessGroupAffinity(                 WINAPI_ProcessHandle hProcess, PUSHORT GroupCount, PUSHORT GroupArray);
  BOOL                         GetProcessHandleCount(                   WINAPI_ProcessHandle hProcess, PDWORD pdwHandleCount);
  DWORD                        GetProcessId(                            HANDLE Process);
  DWORD                        GetProcessIdOfThread(                    HANDLE Thread);
  BOOL                         GetProcessIoCounters(                    WINAPI_ProcessHandle hProcess, PIO_COUNTERS lpIoCounters);
  BOOL                         GetProcessPriorityBoost(                 WINAPI_ProcessHandle hProcess, PBOOL pDisablePriorityBoost);
  BOOL                         GetProcessShutdownParameters(            LPDWORD lpdwLevel, LPDWORD lpdwFlags);
  BOOL                         GetProcessTimes(                         WINAPI_ProcessHandle hProcess, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime);
  DWORD                        GetProcessVersion(                       DWORD ProcessId);
  BOOL                         GetProcessWorkingSetSize(                WINAPI_ProcessHandle hProcess, PSIZE_T lpMinimumWorkingSetSize, PSIZE_T lpMaximumWorkingSetSize);
  BOOL                         GetProcessWorkingSetSizeEx(              WINAPI_ProcessHandle hProcess, PSIZE_T lpMinimumWorkingSetSize, PSIZE_T lpMaximumWorkingSetSize, PDWORD Flags);
  BOOL                         GetProcessorSystemCycleTime(             USHORT Group, PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION Buffer, PDWORD ReturnedLength);
  VOID                         GetStartupInfo(                          LPSTARTUPINFO lpStartupInfo);
  BOOL                         NeedCurrentDirectoryForExePath(          LPCTSTR ExeName);
  HANDLE                       OpenProcess(                             WINAPI_PROCESS_ACCESS_MASK dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);
  BOOL                         QueryFullProcessImageName(               WINAPI_ProcessHandle hProcess, WINAPI_QueryFullProcessImageNameFlags dwFlags, LPTSTR lpExeName, PDWORD lpdwSize);
  BOOL                         QueryProcessAffinityUpdateMode(          HANDLE ProcessHandle, DWORD lpdwFlags);
  BOOL                         QueryProcessCycleTime(                   HANDLE ProcessHandle, PULONG64 CycleTime);
  BOOL                         SetEnvironmentVariable(                  LPCTSTR lpName, LPCTSTR lpValue);
  BOOL                         SetPriorityClass(                        WINAPI_ProcessHandle hProcess, WINAPI_PriorityClass dwPriorityClass);
  BOOL                         SetProcessAffinityMask(                  WINAPI_ProcessHandle hProcess, DWORD_PTR dwProcessAffinityMask);
  BOOL                         SetProcessAffinityUpdateMode(            HANDLE ProcessHandle, DWORD dwFlags);
  BOOL                         SetProcessPriorityBoost(                 WINAPI_ProcessHandle hProcess, BOOL DisablePriorityBoost);
  BOOL                         SetProcessShutdownParameters(            DWORD dwLevel, WINAPI_ProcessShutdownFlags dwFlags);
  BOOL                         SetProcessWorkingSetSize(                WINAPI_ProcessHandle hProcess, SIZE_T dwMinimumWorkingSetSize, SIZE_T dwMaximumWorkingSetSize);
  BOOL                         SetProcessWorkingSetSizeEx(              WINAPI_ProcessHandle hProcess, SIZE_T dwMinimumWorkingSetSize, SIZE_T dwMaximumWorkingSetSize, DWORD Flags);
  BOOL                         TerminateProcess(                        WINAPI_ProcessHandle hProcess, UINT uExitCode);
  HANDLE                       CreateRemoteThread(                      WINAPI_ProcessHandle hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
  HANDLE                       CreateRemoteThreadEx(                    WINAPI_ProcessHandle hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, LPDWORD lpThreadId);
  HANDLE                       CreateThread(                            LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, WINAPI_ThreadCreationFlags dwCreationFlags, LPDWORD lpThreadId);
  VOID                         ExitThread(                              DWORD dwExitCode);
  WINAPI_ThreadHandle          GetCurrentThread(                        );
  DWORD                        GetCurrentThreadId(                      );
  BOOL                         GetExitCodeThread(                       WINAPI_ThreadHandle hThread, LPDWORD lpExitCode);
  BOOL                         GetThreadGroupAffinity(                  WINAPI_ThreadHandle hThread, PGROUP_AFFINITY GroupAffinity);
  DWORD                        GetThreadId(                             HANDLE Thread);
  BOOL                         GetThreadIdealProcessorEx(               WINAPI_ThreadHandle hThread, PPROCESSOR_NUMBER lpIdealProcessor);
  BOOL                         GetThreadIOPendingFlag(                  WINAPI_ThreadHandle hThread, PBOOL lpIOIsPending);
  int                          GetThreadPriority(                       WINAPI_ThreadHandle hThread);
  BOOL                         GetThreadPriorityBoost(                  WINAPI_ThreadHandle hThread, PBOOL pDisablePriorityBoost);
  BOOL                         GetThreadTimes(                          WINAPI_ThreadHandle hThread, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime);
  HANDLE                       OpenThread(                              WINAPI_THREAD_ACCESS_MASK dwDesiredAccess, BOOL bInheritHandle, DWORD dwThreadId);
  BOOL                         QueryThreadCycleTime(                    HANDLE ThreadHandle, PULONG64 CycleTime);
  DWORD                        ResumeThread(                            WINAPI_ThreadHandle hThread);
  DWORD_PTR                    SetThreadAffinityMask(                   WINAPI_ThreadHandle hThread, DWORD_PTR dwThreadAffinityMask);
  BOOL                         SetThreadGroupAffinity(                  WINAPI_ThreadHandle hThread, GROUP_AFFINITY* GroupAffinity);
  DWORD                        SetThreadIdealProcessor(                 WINAPI_ThreadHandle hThread, DWORD dwIdealProcessor);
  BOOL                         SetThreadIdealProcessorEx(               WINAPI_ThreadHandle hThread, PPROCESSOR_NUMBER lpIdealProcessor, PPROCESSOR_NUMBER lpPreviousIdealProcessor);
  BOOL                         SetThreadPriority(                       WINAPI_ThreadHandle hThread, WINAPI_ThreadPriority nPriority);
  BOOL                         SetThreadPriorityBoost(                  WINAPI_ThreadHandle hThread, BOOL DisablePriorityBoost);
  BOOL                         SetThreadStackGuarantee(                 PULONG StackSizeInBytes);
  VOID                         Sleep(                                   WINAPI_WaitTimeout dwMilliseconds);
  DWORD                        SleepEx(                                 WINAPI_WaitTimeout dwMilliseconds, BOOL bAlertable);
  DWORD                        SuspendThread(                           WINAPI_ThreadHandle hThread);
  BOOL                         SwitchToThread(                          );
  BOOL                         TerminateThread(                         WINAPI_ThreadHandle hThread, DWORD dwExitCode);
  DWORD                        TlsAlloc(                                );
  BOOL                         TlsFree(                                 DWORD dwTlsIndex);
  LPVOID                       TlsGetValue(                             DWORD dwTlsIndex);
  BOOL                         TlsSetValue(                             DWORD dwTlsIndex, LPVOID lpTlsValue);
  VOID                         DeleteProcThreadAttributeList(           LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList);
  BOOL                         InitializeProcThreadAttributeList(       LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, DWORD dwAttributeCount, DWORD dwFlags, PSIZE_T lpSize);
  BOOL                         UpdateProcThreadAttribute(               LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, DWORD dwFlags, WINAPI_ProcThreadAttribute Attribute, PVOID lpValue, SIZE_T cbSize, PVOID lpPreviousValue, PSIZE_T lpReturnSize);
  BOOL                         IsWow64Process(                          WINAPI_ProcessHandle hProcess, PBOOL Wow64Process);
  DWORD                        Wow64SuspendThread(                      WINAPI_ThreadHandle hThread);
  BOOL                         AssignProcessToJobObject(                HANDLE hJob, WINAPI_ProcessHandle hProcess);
  HANDLE                       CreateJobObject(                         LPSECURITY_ATTRIBUTES lpJobAttributes, LPCTSTR lpName);
  BOOL                         IsProcessInJob(                          HANDLE ProcessHandle, HANDLE JobHandle, PBOOL Result);
  HANDLE                       OpenJobObject(                           DWORD dwDesiredAccess, BOOL bInheritHandles, LPCTSTR lpName);
  BOOL                         QueryInformationJobObject(               HANDLE hJob, JOBOBJECTINFOCLASS JobObjectInfoClass, LPVOID lpJobObjectInfo, DWORD cbJobObjectInfoLength, LPDWORD lpReturnLength);
  BOOL                         SetInformationJobObject(                 HANDLE hJob, JOBOBJECTINFOCLASS JobObjectInfoClass, LPVOID lpJobObjectInfo, DWORD cbJobObjectInfoLength);
  BOOL                         TerminateJobObject(                      HANDLE hJob, UINT uExitCode);
  BOOL                         CallbackMayRunLong(                      PTP_CALLBACK_INSTANCE pci);
  VOID                         CancelThreadpoolIo(                      PTP_IO pio);
  VOID                         StartThreadpoolIo(                       PTP_IO pio);
  VOID                         CloseThreadpool(                         PTP_POOL ptpp);
  VOID                         CloseThreadpoolCleanupGroup(             PTP_CLEANUP_GROUP ptpcg);
  VOID                         CloseThreadpoolCleanupGroupMembers(      PTP_CLEANUP_GROUP ptpcg, BOOL fCancelPendingCallbacks, PVOID pvCleanupContext);
  VOID                         CloseThreadpoolIo(                       PTP_IO pio);
  VOID                         CloseThreadpoolTimer(                    PTP_TIMER pti);
  VOID                         CloseThreadpoolWait(                     PTP_WAIT pwa);
  VOID                         CloseThreadpoolWork(                     PTP_WORK pwk);
  PTP_POOL                     CreateThreadpool(                        PVOID reserved);
  PTP_CLEANUP_GROUP            CreateThreadpoolCleanupGroup(            );
  PTP_IO                       CreateThreadpoolIo(                      HANDLE fl, PTP_WIN32_IO_CALLBACK pfnio, PVOID pv, PTP_CALLBACK_ENVIRON pcbe);
  PTP_TIMER                    CreateThreadpoolTimer(                   PTP_TIMER_CALLBACK pfnti, PVOID pv, PTP_CALLBACK_ENVIRON pcbe);
  PTP_WAIT                     CreateThreadpoolWait(                    PTP_WAIT_CALLBACK pfnwa, PVOID pv, PTP_CALLBACK_ENVIRON pcbe);
  PTP_WORK                     CreateThreadpoolWork(                    PTP_WORK_CALLBACK pfnwk, PVOID pv, PTP_CALLBACK_ENVIRON pcbe);
  VOID                         DisassociateCurrentThreadFromCallback(   PTP_CALLBACK_INSTANCE pci);
  VOID                         FreeLibraryWhenCallbackReturns(          PTP_CALLBACK_INSTANCE pci, HMODULE mod);
  BOOL                         IsThreadpoolTimerSet(                    PTP_TIMER pti);
  VOID                         LeaveCriticalSectionWhenCallbackReturns( PTP_CALLBACK_INSTANCE pci, PCRITICAL_SECTION pcs);
  BOOL                         QueryThreadpoolStackInformation(         PTP_POOL ptpp, PTP_POOL_STACK_INFORMATION ptpsi);
  VOID                         ReleaseMutexWhenCallbackReturns(         PTP_CALLBACK_INSTANCE pci, HANDLE mut);
  VOID                         ReleaseSemaphoreWhenCallbackReturns(     PTP_CALLBACK_INSTANCE pci, HANDLE sem, DWORD crel);
  VOID                         SetEventWhenCallbackReturns(             PTP_CALLBACK_INSTANCE pci, HANDLE evt);
  VOID                         SetThreadpoolCallbackPriority(           PTP_CALLBACK_ENVIRON pcbe, TP_CALLBACK_PRIORITY Priority);
  BOOL                         SetThreadpoolStackInformation(           PTP_POOL ptpp, PTP_POOL_STACK_INFORMATION ptpsi);
  VOID                         SetThreadpoolThreadMaximum(              PTP_POOL ptpp, DWORD cthrdMost);
  BOOL                         SetThreadpoolThreadMinimum(              PTP_POOL ptpp, DWORD cthrdMic);
  VOID                         SetThreadpoolTimer(                      PTP_TIMER pti, PFILETIME pftDueTime, DWORD msPeriod, DWORD msWindowLength);
  VOID                         SetThreadpoolWait(                       PTP_WAIT pwa, HANDLE h, PFILETIME pftTimeout);
  VOID                         SubmitThreadpoolWork(                    PTP_WORK pwk);
  BOOL                         TrySubmitThreadpoolCallback(             PTP_SIMPLE_CALLBACK pfns, PVOID pv, PTP_CALLBACK_ENVIRON pcbe);
  VOID                         WaitForThreadpoolIoCallbacks(            PTP_IO pio, BOOL fCancelPendingCallbacks);
  VOID                         WaitForThreadpoolTimerCallbacks(         PTP_TIMER pti, BOOL fCancelPendingCallbacks);
  VOID                         WaitForThreadpoolWaitCallbacks(          PTP_WAIT pwa, BOOL fCancelPendingCallbacks);
  VOID                         WaitForThreadpoolWorkCallbacks(          PTP_WORK pwk, BOOL fCancelPendingCallbacks);
  BOOL                         BindIoCompletionCallback(                HANDLE FileHandle, LPOVERLAPPED_COMPLETION_ROUTINE Function, ULONG Flags);
  BOOL                         QueueUserWorkItem(                       LPTHREAD_START_ROUTINE Function, PVOID Context, WINAPI_WorkItemFlags Flags);
  BOOL                         ConvertFiberToThread(                    );
  LPVOID                       ConvertThreadToFiber(                    LPVOID lpParameter);
  LPVOID                       ConvertThreadToFiberEx(                  LPVOID lpParameter, DWORD dwFlags);
  LPVOID                       CreateFiber(                             SIZE_T dwStackSize, LPFIBER_START_ROUTINE lpStartAddress, LPVOID lpParameter);
  LPVOID                       CreateFiberEx(                           SIZE_T dwStackCommitSize, SIZE_T dwStackReserveSize, DWORD dwFlags, LPFIBER_START_ROUTINE lpStartAddress, LPVOID lpParameter);
  VOID                         DeleteFiber(                             LPVOID lpFiber);
  DWORD                        FlsAlloc(                                PFLS_CALLBACK_FUNCTION lpCallback);
  BOOL                         FlsFree(                                 DWORD dwFlsIndex);
  PVOID                        FlsGetValue(                             DWORD dwFlsIndex);
  BOOL                         FlsSetValue(                             DWORD dwFlsIndex, PVOID lpFlsData);
  BOOL                         IsThreadAFiber(                          );
  VOID                         SwitchToFiber(                           LPVOID lpFiber);
  BOOL                         AllocateUserPhysicalPagesNuma(           WINAPI_ProcessHandle hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray, DWORD nndPreferred);
  BOOL                         GetNumaAvailableMemoryNode(              UCHAR Node, PULONGLONG AvailableBytes);
  BOOL                         GetNumaAvailableMemoryNodeEx(            USHORT Node, PULONGLONG AvailableBytes);
  BOOL                         GetNumaHighestNodeNumber(                PULONG HighestNodeNumber);
  BOOL                         GetNumaNodeNumberFromHandle(             HANDLE hFile, PUSHORT NodeNumber);
  BOOL                         GetNumaNodeProcessorMask(                UCHAR Node, PULONGLONG ProcessorMask);
  BOOL                         GetNumaNodeProcessorMaskEx(              USHORT Node, PGROUP_AFFINITY ProcessorMask);
  BOOL                         GetNumaProcessorNode(                    UCHAR Processor, PUCHAR NodeNumber);
  BOOL                         GetNumaProcessorNodeEx(                  PPROCESSOR_NUMBER Processor, PUSHORT NodeNumber);
  BOOL                         GetNumaProximityNode(                    ULONG ProximityId, PUCHAR NodeNumber);
  BOOL                         GetNumaProximityNodeEx(                  ULONG ProximityId, PUSHORT NodeNumber);
  DWORD                        GetActiveProcessorCount(                 WORD GroupNumber);
  WORD                         GetActiveProcessorGroupCount(            );
  VOID                         GetCurrentProcessorNumberEx(             PPROCESSOR_NUMBER ProcNumber);
  BOOL                         GetLogicalProcessorInformation(          PSYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer, PDWORD ReturnLength);
  BOOL                         GetLogicalProcessorInformationEx(        LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType, PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX Buffer, PDWORD ReturnedLength);
  DWORD                        GetMaximumProcessorCount(                WORD GroupNumber);
  WORD                         GetMaximumProcessorGroupCount(           );
  BOOL                         QueryIdleProcessorCycleTime(             PULONG BufferLength, PULONG64 ProcessorIdleCycleTime);
  BOOL                         QueryIdleProcessorCycleTimeEx(           USHORT Group, PULONG BufferLength, PULONG64 ProcessorIdleCycleTime);
  BOOL                         CreateUmsCompletionList(                 PUMS_COMPLETION_LIST* UmsCompletionList);
  BOOL                         CreateUmsThreadContext(                  PUMS_CONTEXT* lpUmsThread);
  BOOL                         DeleteUmsCompletionList(                 PUMS_COMPLETION_LIST UmsCompletionList);
  BOOL                         DeleteUmsThreadContext(                  PUMS_CONTEXT UmsThread);
  BOOL                         DequeueUmsCompletionListItems(           PUMS_COMPLETION_LIST UmsCompletionList, DWORD WaitTimeOut, PUMS_CONTEXT* UmsThreadList);
  BOOL                         EnterUmsSchedulingMode(                  PUMS_SCHEDULER_STARTUP_INFO SchedulerStartupInfo);
  BOOL                         ExecuteUmsThread(                        PUMS_CONTEXT UmsThread);
  PUMS_CONTEXT                 GetCurrentUmsThread(                     );
  PUMS_CONTEXT                 GetNextUmsListItem(                      PUMS_CONTEXT UmsContext);
  BOOL                         GetUmsCompletionListEvent(               PUMS_COMPLETION_LIST UmsCompletionList, PHANDLE UmsCompletionEvent);
  BOOL                         QueryUmsThreadInformation(               PUMS_CONTEXT UmsThread, UMS_THREAD_INFO_CLASS UmsThreadInfoClass, PVOID UmsThreadInformation, ULONG UmsThreadInformationLength, PULONG ReturnLength);
  BOOL                         SetUmsThreadInformation(                 PUMS_CONTEXT UmsThread, UMS_THREAD_INFO_CLASS UmsThreadInfoClass, PVOID UmsThreadInformation, ULONG UmsThreadInformationLength);
  BOOL                         UmsThreadYield(                          PVOID SchedulerParam);
  UINT                         WinExec(                                 LPCSTR lpCmdLine, UINT uCmdShow);
  BOOL                         ActivateActCtx(                          HANDLE hActCtx, ULONG_PTR* lpCookie);
  void                         AddRefActCtx(                            HANDLE hActCtx);
  HANDLE                       CreateActCtx(                            PACTCTX pActCtx);
  BOOL                         DeactivateActCtx(                        WINAPI_DeactivateActCtxFlags dwFlags, ULONG_PTR ulCookie);
  BOOL                         FindActCtxSectionGuid(                   WINAPI_FIND_ACTCTX_SECTION_FLAGS dwFlags, GUID* lpExtensionGuid, WINAPI_ACTIVATION_CONTEXT_SECTION ulSectionId, GUID* lpGuidToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData);
  BOOL                         FindActCtxSectionString(                 WINAPI_FIND_ACTCTX_SECTION_FLAGS dwFlags, GUID* lpExtensionGuid, WINAPI_ACTIVATION_CONTEXT_SECTION ulSectionId, LPCTSTR lpStringToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData);
  BOOL                         GetCurrentActCtx(                        HANDLE* lphActCtx);
  BOOL                         QueryActCtxW(                            WINAPI_QueryActCtxFlags dwFlags, HANDLE hActCtx, PVOID pvSubInstance, WINAPI_ActivationContextInfoClass ulInfoClass, PVOID pvBuffer, SIZE_T cbBuffer, SIZE_T* pcbWrittenOrRequired);
  BOOL                         QueryActCtxSettingsW(                    DWORD dwFlags, HANDLE hActCtx, PCWSTR settingsNameSpace, PCWSTR settingName, PWSTR pvBuffer, SIZE_T dwBuffer, SIZE_T* pdwWrittenOrRequired);
  void                         ReleaseActCtx(                           HANDLE hActCtx);
  BOOL                         ZombifyActCtx(                           HANDLE hActCtx);
  ATOM                         AddAtom(                                 LPCTSTR lpString);
  ATOM                         DeleteAtom(                              ATOM nAtom);
  ATOM                         FindAtom(                                LPCTSTR lpString);
  UINT                         GetAtomName(                             ATOM nAtom, LPTSTR lpBuffer, int nSize);
  ATOM                         GlobalAddAtom(                           LPCTSTR lpString);
  ATOM                         GlobalDeleteAtom(                        ATOM nAtom);
  ATOM                         GlobalFindAtom(                          LPCTSTR lpString);
  UINT                         GlobalGetAtomName(                       ATOM nAtom, LPTSTR lpBuffer, int nSize);
  BOOL                         InitAtomTable(                           DWORD nSize);
  BOOL                         BuildCommDCB(                            LPCTSTR lpDef, LPDCB lpDCB);
  BOOL                         BuildCommDCBAndTimeouts(                 LPCTSTR lpDef, LPDCB lpDCB, LPCOMMTIMEOUTS lpCommTimeouts);
  BOOL                         ClearCommBreak(                          HANDLE hFile);
  BOOL                         ClearCommError(                          HANDLE hFile, LPDWORD lpErrors, LPCOMSTAT lpStat);
  BOOL                         CommConfigDialog(                        LPCTSTR lpszName, HWND hWnd, LPCOMMCONFIG lpCC);
  BOOL                         EscapeCommFunction(                      HANDLE hFile, DWORD dwFunc);
  BOOL                         GetCommConfig(                           HANDLE hCommDev, LPCOMMCONFIG lpCC, LPDWORD lpdwSize);
  BOOL                         GetCommMask(                             HANDLE hFile, LPDWORD lpEvtMask);
  BOOL                         GetCommModemStatus(                      HANDLE hFile, LPDWORD lpModemStat);
  BOOL                         GetCommProperties(                       HANDLE hFile, LPCOMMPROP lpCommProp);
  BOOL                         GetCommState(                            HANDLE hFile, LPDCB lpDCB);
  BOOL                         GetCommTimeouts(                         HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts);
  BOOL                         GetDefaultCommConfig(                    LPCTSTR lpszName, LPCOMMCONFIG lpCC, LPDWORD lpdwSize);
  BOOL                         PurgeComm(                               HANDLE hFile, DWORD dwFlags);
  BOOL                         SetCommBreak(                            HANDLE hFile);
  BOOL                         SetCommConfig(                           HANDLE hCommDev, LPCOMMCONFIG lpCC, DWORD dwSize);
  BOOL                         SetCommMask(                             HANDLE hFile, DWORD dwEvtMask);
  BOOL                         SetCommState(                            HANDLE hFile, LPDCB lpDCB);
  BOOL                         SetCommTimeouts(                         HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts);
  BOOL                         SetDefaultCommConfig(                    LPCTSTR lpszName, LPCOMMCONFIG lpCC, DWORD dwSize);
  BOOL                         SetupComm(                               HANDLE hFile, DWORD dwInQueue, DWORD dwOutQueue);
  BOOL                         TransmitCommChar(                        HANDLE hFile, char cChar);
  BOOL                         WaitCommEvent(                           HANDLE hFile, LPDWORD lpEvtMask, LPOVERLAPPED lpOverlapped);
  BOOL                         AddConsoleAlias(                         LPCTSTR Source, LPCTSTR Target, LPCTSTR ExeName);
  BOOL                         AllocConsole(                            );
  BOOL                         AttachConsole(                           DWORD dwProcessId);
  HANDLE                       CreateConsoleScreenBuffer(               DWORD dwDesiredAccess, DWORD dwShareMode, SECURITY_ATTRIBUTES* lpSecurityAttributes, DWORD dwFlags, LPVOID lpScreenBufferData);
  BOOL                         FillConsoleOutputAttribute(              HANDLE hConsoleOutput, WINAPI_ConsoleAttribute wAttribute, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfAttrsWritten);
  BOOL                         FillConsoleOutputCharacter(              HANDLE hConsoleOutput, TCHAR cCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten);
  BOOL                         FlushConsoleInputBuffer(                 HANDLE hConsoleInput);
  BOOL                         FreeConsole(                             );
  BOOL                         GenerateConsoleCtrlEvent(                DWORD dwCtrlEvent, DWORD dwProcessGroupId);
  DWORD                        GetConsoleAlias(                         LPTSTR lpSource, LPTSTR lpTargetBuffer, DWORD TargetBufferLength, LPTSTR lpExeName);
  DWORD                        GetConsoleAliases(                       LPTSTR lpAliasBuffer, DWORD AliasBufferLength, LPTSTR lpExeName);
  DWORD                        GetConsoleAliasesLength(                 LPTSTR lpExeName);
  DWORD                        GetConsoleAliasExes(                     LPTSTR lpExeNameBuffer, DWORD ExeNameBufferLength);
  DWORD                        GetConsoleAliasExesLength(               );
  WINAPI_CodePageEnum          GetConsoleCP(                            );
  BOOL                         GetConsoleCursorInfo(                    HANDLE hConsoleOutput, PCONSOLE_CURSOR_INFO lpConsoleCursorInfo);
  BOOL                         GetConsoleDisplayMode(                   LPDWORD lpModeFlags);
  COORD                        GetConsoleFontSize(                      HANDLE hConsoleOutput, DWORD nFont);
  BOOL                         GetConsoleHistoryInfo(                   PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo);
  BOOL                         GetConsoleMode(                          HANDLE hConsoleHandle, WINAPI_ConsoleModeFlags* lpMode);
  DWORD                        GetConsoleOriginalTitle(                 LPTSTR lpConsoleTitle, DWORD nSize);
  UINT                         GetConsoleOutputCP(                      );
  DWORD                        GetConsoleProcessList(                   LPDWORD lpdwProcessList, DWORD dwProcessCount);
  BOOL                         GetConsoleScreenBufferInfo(              HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo);
  BOOL                         GetConsoleScreenBufferInfoEx(            HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx);
  BOOL                         GetConsoleSelectionInfo(                 PCONSOLE_SELECTION_INFO lpConsoleSelectionInfo);
  DWORD                        GetConsoleTitle(                         LPTSTR lpConsoleTitle, DWORD nSize);
  HWND                         GetConsoleWindow(                        );
  BOOL                         GetCurrentConsoleFont(                   HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFO lpConsoleCurrentFont);
  BOOL                         GetCurrentConsoleFontEx(                 HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx);
  COORD                        GetLargestConsoleWindowSize(             HANDLE hConsoleOutput);
  BOOL                         GetNumberOfConsoleInputEvents(           HANDLE hConsoleInput, LPDWORD lpcNumberOfEvents);
  BOOL                         GetNumberOfConsoleMouseButtons(          LPDWORD lpNumberOfMouseButtons);
  WINAPI_FILE_HANDLE           GetStdHandle(                            WINAPI_StdHandle nStdHandle);
  BOOL                         PeekConsoleInput(                        HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead);
  BOOL                         ReadConsole(                             HANDLE hConsoleInput, LPVOID lpBuffer, DWORD nNumberOfCharsToRead, LPDWORD lpNumberOfCharsRead, LPVOID pInputControl);
  BOOL                         ReadConsoleInput(                        HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead);
  BOOL                         ReadConsoleOutput(                       HANDLE hConsoleOutput, PCHAR_INFO lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpReadRegion);
  BOOL                         ReadConsoleOutputAttribute(              HANDLE hConsoleOutput, WINAPI_ConsoleAttribute* lpAttribute, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfAttrsRead);
  BOOL                         ReadConsoleOutputCharacter(              HANDLE hConsoleOutput, LPTSTR lpCharacter, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfCharsRead);
  BOOL                         ScrollConsoleScreenBuffer(               HANDLE hConsoleOutput, SMALL_RECT* lpScrollRectangle, SMALL_RECT* lpClipRectangle, COORD dwDestinationOrigin, CHAR_INFO* lpFill);
  BOOL                         SetConsoleActiveScreenBuffer(            HANDLE hConsoleOutput);
  BOOL                         SetConsoleCP(                            WINAPI_CodePageEnum wCodePageID);
  BOOL                         SetConsoleCtrlHandler(                   PHANDLER_ROUTINE HandlerRoutine, BOOL Add);
  BOOL                         SetConsoleCursorInfo(                    HANDLE hConsoleOutput, CONSOLE_CURSOR_INFO* lpConsoleCursorInfo);
  BOOL                         SetConsoleCursorPosition(                HANDLE hConsoleOutput, COORD dwCursorPosition);
  BOOL                         SetConsoleDisplayMode(                   HANDLE hConsoleOutput, DWORD dwFlags, PCOORD lpNewScreenBufferDimensions);
  BOOL                         SetConsoleHistoryInfo(                   PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo);
  BOOL                         SetConsoleMode(                          HANDLE hConsoleHandle, WINAPI_ConsoleModeFlags dwMode);
  BOOL                         SetConsoleOutputCP(                      WINAPI_CodePageEnum wCodePageID);
  BOOL                         SetConsoleScreenBufferInfoEx(            HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx);
  BOOL                         SetConsoleScreenBufferSize(              HANDLE hConsoleOutput, COORD dwSize);
  BOOL                         SetConsoleTextAttribute(                 HANDLE hConsoleOutput, WINAPI_ConsoleAttribute wAttributes);
  BOOL                         SetConsoleTitle(                         LPCTSTR lpConsoleTitle);
  BOOL                         SetConsoleWindowInfo(                    HANDLE hConsoleOutput, BOOL bAbsolute, SMALL_RECT* lpConsoleWindow);
  BOOL                         SetCurrentConsoleFontEx(                 HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx);
  BOOL                         SetStdHandle(                            WINAPI_StdHandle nStdHandle, HANDLE hHandle);
  BOOL                         WriteConsole(                            HANDLE hConsoleOutput, LPCTSTR lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved);
  BOOL                         WriteConsoleInput(                       HANDLE hConsoleInput, INPUT_RECORD* lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsWritten);
  BOOL                         WriteConsoleOutput(                      HANDLE hConsoleOutput, CHAR_INFO* lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpWriteRegion);
  BOOL                         WriteConsoleOutputAttribute(             HANDLE hConsoleOutput, WINAPI_ConsoleAttribute* lpAttribute, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfAttrsWritten);
  BOOL                         WriteConsoleOutputCharacter(             HANDLE hConsoleOutput, LPCTSTR lpCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten);
  BOOL                         DeviceIoControl(                         HANDLE hDevice, WINAPI_IOCTL dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped);
  BOOL                         Beep(                                    DWORD dwFreq, DWORD dwDuration);
  USHORT                       RtlCaptureStackBackTrace(                ULONG FramesToSkip, ULONG FramesToCapture, PVOID* BackTrace, PULONG BackTraceHash);
  void                         FatalAppExit(                            UINT uAction, LPCTSTR lpMessageText);
  DWORD                        FormatMessage(                           WINAPI_FormatMessageFlags dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPTSTR lpBuffer, DWORD nSize, va_list* Arguments);
  WINAPI_SEM_FLAGS             GetErrorMode(                            );
  WINAPI_ERROR_CODE            GetLastError(                            );
  WINAPI_SEM_FLAGS_DWORD       GetThreadErrorMode(                      );
  PVOID                        RtlLookupFunctionEntry(                  ULONGLONG ControlPC, PULONGLONG ImageBase, PULONGLONG TargetGp);
  PVOID                        RtlPcToFileHeader(                       PVOID PcValue, PVOID* BaseOfImage);
  WINAPI_SEM_FLAGS             SetErrorMode(                            WINAPI_SEM_FLAGS uMode);
  void                         SetLastError(                            WINAPI_ERROR_CODE dwErrCode);
  BOOL                         SetThreadErrorMode(                      WINAPI_SEM_FLAGS_DWORD dwNewMode, WINAPI_SEM_FLAGS_DWORD* lpOldMode);
  BOOL                         CloseHandle(                             HANDLE hObject);
  BOOL                         DuplicateHandle(                         WINAPI_ProcessHandle hSourceProcessHandle, WINAPI_PROCESS_THREAD_HANDLE hSourceHandle, WINAPI_ProcessHandle hTargetProcessHandle, LPHANDLE lpTargetHandle, WINAPI_StandardAccessRights dwDesiredAccess, BOOL bInheritHandle, WINAPI_DuplicateHandleFlags dwOptions);
  BOOL                         GetHandleInformation(                    HANDLE hObject, LPDWORD lpdwFlags);
  BOOL                         SetHandleInformation(                    HANDLE hObject, WINAPI_HandleFlags dwMask, WINAPI_HandleFlags dwFlags);
  HANDLE                       CreateMailslot(                          LPCTSTR lpName, DWORD nMaxMessageSize, DWORD lReadTimeout, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
  BOOL                         GetMailslotInfo(                         HANDLE hMailslot, LPDWORD lpMaxMessageSize, LPDWORD lpNextSize, LPDWORD lpMessageCount, LPDWORD lpReadTimeout);
  BOOL                         SetMailslotInfo(                         HANDLE hMailslot, DWORD lReadTimeout);
  BOOL                         AdjustCalendarDate(                      LPCALDATETIME lpCalDateTime, CALDATETIME_DATEUNIT calUnit, INT amount);
  int                          CompareStringOrdinal(                    LPCWSTR lpString1, int cchCount1, LPCWSTR lpString2, int cchCount2, BOOL bIgnoreCase);
  BOOL                         ConvertCalDateTimeToSystemTime(          LPCALDATETIME lpCalDateTime, SYSTEMTIME* lpSysTime);
  LCID                         ConvertDefaultLocale(                    LCID Locale);
  BOOL                         ConvertSystemTimeToCalDateTime(          SYSTEMTIME lpSysTime, CALID calId, LPCALDATETIME lpCalDateTime);
  BOOL                         EnumCalendarInfo(                        CALINFO_ENUMPROC pCalInfoEnumProc, LCID Locale, CALID Calendar, CALTYPE CalType);
  BOOL                         EnumCalendarInfoEx(                      CALINFO_ENUMPROCEX pCalInfoEnumProcEx, LCID Locale, CALID Calendar, CALTYPE CalType);
  BOOL                         EnumCalendarInfoExEx(                    CALINFO_ENUMPROCEXEX pCalInfoEnumProcExEx, LPCWSTR lpLocaleName, CALID Calendar, LPCWSTR lpReserved, CALTYPE CalType, LPARAM lParam);
  BOOL                         EnumDateFormats(                         DATEFMT_ENUMPROC lpDateFmtEnumProc, LCID Locale, WINAPI_GetDateFormatFlags dwFlags);
  BOOL                         EnumDateFormatsEx(                       DATEFMT_ENUMPROCEX lpDateFmtEnumProcEx, LCID Locale, WINAPI_GetDateFormatFlags dwFlags);
  BOOL                         EnumDateFormatsExEx(                     DATEFMT_ENUMPROCEXEX lpDateFmtEnumProcExEx, LPCWSTR lpLocaleName, WINAPI_GetDateFormatFlags dwFlags, LPARAM lParam);
  BOOL                         EnumLanguageGroupLocales(                LANGGROUPLOCALE_ENUMPROC lpLangGroupLocaleEnumProc, LGRPID LanguageGroup, DWORD dwFlags, LONG_PTR lParam);
  BOOL                         EnumSystemCodePages(                     CODEPAGE_ENUMPROC lpCodePageEnumProc, WINAPI_CodePageEnumerationFlags dwFlags);
  BOOL                         EnumSystemGeoID(                         GEOCLASS GeoClass, GEOID ParentGeoId, GEO_ENUMPROC lpGeoEnumProc);
  BOOL                         EnumSystemLanguageGroups(                LANGUAGEGROUP_ENUMPROC lpLanguageGroupEnumProc, DWORD dwFlags, LONG_PTR lParam);
  BOOL                         EnumSystemLocales(                       LOCALE_ENUMPROC lpLocaleEnumProc, WINAPI_LocaleEnumerationFlags dwFlags);
  BOOL                         EnumSystemLocalesEx(                     LOCALE_ENUMPROCEX lpLocaleEnumProcEx, WINAPI_EnumSystemLocalesExFlags dwFlags, LPARAM lParam, LPVOID lpReserved);
  BOOL                         EnumTimeFormats(                         TIMEFMT_ENUMPROC lpTimeFmtEnumProc, LCID Locale, WINAPI_GetTimeFormatFlags dwFlags);
  BOOL                         EnumTimeFormatsEx(                       TIMEFMT_ENUMPROCEX lpTimeFmtEnumProcEx, LPCWSTR lpLocaleName, WINAPI_GetTimeFormatFlags dwFlags, LPARAM lParam);
  int                          FindNLSString(                           LCID Locale, DWORD dwFindNLSStringFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, LPINT pcchFound);
  int                          FindNLSStringEx(                         LPCWSTR lpLocaleName, DWORD dwFindNLSStringFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, LPINT pcchFound, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM lParam);
  int                          FindStringOrdinal(                       DWORD dwFindStringOrdinalFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, BOOL bIgnoreCase);
  int                          FoldString(                              WINAPI_MappingFlags dwMapFlags, LPCTSTR lpSrcStr, int cchSrc, LPTSTR lpDestStr, int cchDest);
  UINT                         GetACP(                                  );
  BOOL                         GetCalendarDateFormatEx(                 LPCWSTR lpszLocale, DWORD dwFlags, LPCALDATETIME lpCalDateTime, LPCWSTR lpFormat, LPWSTR lpDateStr, int cchDate);
  int                          GetCalendarInfo(                         LCID Locale, CALID Calendar, CALTYPE CalType, LPTSTR lpCalData, int cchData, LPDWORD lpValue);
  int                          GetCalendarInfoEx(                       LPCWSTR lpLocaleName, CALID Calendar, LPCWSTR lpReserved, CALTYPE CalType, LPWSTR lpCalData, int cchData, LPDWORD lpValue);
  BOOL                         GetCalendarSupportedDateRange(           CALID Calendar, LPCALDATETIME lpCalMinDateTime, LPCALDATETIME lpCalMaxDateTime);
  BOOL                         GetCPInfo(                               WINAPI_CodePageEnum CodePage, LPCPINFO lpCPInfo);
  BOOL                         GetCPInfoEx(                             WINAPI_CodePageEnum CodePage, DWORD dwFlags, LPCPINFOEX lpCPInfoEx);
  int                          GetCurrencyFormat(                       LCID Locale, DWORD dwFlags, LPCTSTR lpValue, CURRENCYFMT* lpFormat, LPTSTR lpCurrencyStr, int cchCurrency);
  int                          GetCurrencyFormatEx(                     LPCWSTR lpLocaleName, DWORD dwFlags, LPCWSTR lpValue, CURRENCYFMT* lpFormat, LPWSTR lpCurrencyStr, int cchCurrency);
  int                          GetDateFormat(                           LCID Locale, WINAPI_GetDateFormatFlags dwFlags, SYSTEMTIME* lpDate, LPCTSTR lpFormat, LPTSTR lpDateStr, int cchDate);
  int                          GetDateFormatEx(                         LPCWSTR lpLocaleName, WINAPI_GetDateFormatFlags dwFlags, SYSTEMTIME* lpDate, LPCWSTR lpFormat, LPWSTR lpDateStr, int cchDate, LPCWSTR lpCalendar);
  int                          GetDurationFormat(                       LCID Locale, DWORD dwFlags, SYSTEMTIME* lpDuration, ULONGLONG ullDuration, LPCWSTR lpFormat, LPWSTR lpDurationStr, int cchDuration);
  int                          GetDurationFormatEx(                     LPCWSTR lpLocaleName, DWORD dwFlags, SYSTEMTIME* lpDuration, ULONGLONG ullDuration, LPCWSTR lpFormat, LPWSTR lpDurationStr, int cchDuration);
  int                          GetGeoInfo(                              GEOID Location, GEOTYPE GeoType, LPTSTR lpGeoData, int cchData, LANGID LangId);
  int                          GetLocaleInfo(                           LCID Locale, LCTYPE LCType, LPTSTR lpLCData, int cchData);
  int                          GetLocaleInfoEx(                         LPCWSTR lpLocaleName, LCTYPE LCType, LPWSTR lpLCData, int cchData);
  BOOL                         GetNLSVersion(                           NLS_FUNCTION Function, LCID Locale, LPNLSVERSIONINFO lpVersionInformation);
  BOOL                         GetNLSVersionEx(                         NLS_FUNCTION function, LPCWSTR lpLocaleName, LPNLSVERSIONINFOEX lpVersionInformation);
  int                          GetNumberFormat(                         LCID Locale, WINAPI_GetNumberFormatFlags dwFlags, LPCTSTR lpValue, NUMBERFMT* lpFormat, LPTSTR lpNumberStr, int cchNumber);
  int                          GetNumberFormatEx(                       LPCWSTR lpLocaleName, WINAPI_GetNumberFormatFlags dwFlags, LPCWSTR lpValue, NUMBERFMT* lpFormat, LPWSTR lpNumberStr, int cchNumber);
  UINT                         GetOEMCP(                                );
  int                          GetStringScripts(                        DWORD dwFlags, LPCWSTR lpString, int cchString, LPWSTR lpScripts, int cchScripts);
  LANGID                       GetSystemDefaultLangID(                  );
  LCID                         GetSystemDefaultLCID(                    );
  int                          GetSystemDefaultLocaleName(              LPWSTR lpLocaleName, int cchLocaleName);
  LCID                         GetThreadLocale(                         );
  int                          GetTimeFormat(                           LCID Locale, WINAPI_GetTimeFormatFlags dwFlags, SYSTEMTIME* lpTime, LPCTSTR lpFormat, LPTSTR lpTimeStr, int cchTime);
  int                          GetTimeFormatEx(                         LPCWSTR lpLocaleName, WINAPI_GetTimeFormatFlags dwFlags, SYSTEMTIME* lpTime, LPCWSTR lpFormat, LPWSTR lpTimeStr, int cchTime);
  LANGID                       GetUserDefaultLangID(                    );
  LCID                         GetUserDefaultLCID(                      );
  int                          GetUserDefaultLocaleName(                LPWSTR lpLocaleName, int cchLocaleName);
  GEOID                        GetUserGeoID(                            GEOCLASS GeoClass);
  BOOL                         IsCalendarLeapYear(                      CALID calId, UINT year, UINT era);
  BOOL                         IsNLSDefinedString(                      NLS_FUNCTION Function, DWORD dwFlags, LPNLSVERSIONINFO lpVersionInformation, LPCWSTR lpString, INT cchStr);
  BOOL                         IsValidCodePage(                         WINAPI_CodePageEnum CodePage);
  BOOL                         IsValidLanguageGroup(                    LGRPID LanguageGroup, WINAPI_LanguageGroupFlags dwFlags);
  BOOL                         IsValidLocale(                           LCID Locale, WINAPI_LocaleEnumerationFlags dwFlags);
  BOOL                         IsValidLocaleName(                       LPCWSTR lpLocaleName);
  int                          LCIDToLocaleName(                        LCID Locale, LPWSTR lpName, int cchName, DWORD dwFlags);
  int                          LCMapString(                             LCID Locale, WINAPI_LocaleMappingFlags dwMapFlags, LPCTSTR lpSrcStr, int cchSrc, LPTSTR lpDestStr, int cchDest);
  int                          LCMapStringEx(                           LPCWSTR lpLocaleName, WINAPI_LocaleMappingFlags dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM lParam);
  LCID                         LocaleNameToLCID(                        LPCWSTR lpName, DWORD dwFlags);
  int                          ResolveLocaleName(                       LPCWSTR lpNameToResolve, LPWSTR lpLocaleName, int cchLocaleName);
  BOOL                         RtlIsValidLocaleName(                    LPCWSTR LocaleName, ULONG Flags);
  BOOL                         SetCalendarInfo(                         LCID Locale, CALID Calendar, CALTYPE CalType, LPCTSTR lpCalData);
  BOOL                         SetLocaleInfo(                           LCID Locale, LCTYPE LCType, LPCTSTR lpLCData);
  BOOL                         SetThreadLocale(                         LCID Locale);
  BOOL                         SetUserGeoID(                            GEOID GeoId);
  BOOL                         UpdateCalendarDayOfWeek(                 LPCALDATETIME lpCalDateTime);
  BOOL                         VerifyScripts(                           DWORD dwFlags, LPCWSTR lpLocaleScripts, int cchLocaleScripts, LPCWSTR lpTestScripts, int cchTestScripts);
  BOOL                         GetDevicePowerState(                     HANDLE hDevice, BOOL* pfOn);
  BOOL                         GetSystemPowerStatus(                    LPSYSTEM_POWER_STATUS lpSystemPowerStatus);
  BOOL                         IsSystemResumeAutomatic(                 );
  BOOL                         PowerClearRequest(                       HANDLE PowerRequest, POWER_REQUEST_TYPE RequestType);
  HANDLE                       PowerCreateRequest(                      PREASON_CONTEXT Context);
  BOOL                         PowerSetRequest(                         HANDLE PowerRequest, POWER_REQUEST_TYPE RequestType);
  BOOL                         QueryUnbiasedInterruptTime(              PULONGLONG UnbiasedTime);
  EXECUTION_STATE              SetThreadExecutionState(                 EXECUTION_STATE esFlags);
  BOOL                         RequestWakeupLatency(                    LATENCY_TIME latency);
  BOOL                         SetSystemPowerState(                     BOOL fSuspend, BOOL fForce);
  HANDLE                       BeginUpdateResource(                     LPCTSTR pFileName, BOOL bDeleteExistingResources);
  BOOL                         EndUpdateResource(                       HANDLE hUpdate, BOOL fDiscard);
  BOOL                         EnumResourceLanguages(                   HMODULE hModule, LPCTSTR lpType, LPCTSTR lpName, ENUMRESLANGPROC lpEnumFunc, LONG_PTR lParam);
  BOOL                         EnumResourceLanguagesEx(                 HMODULE hModule, LPCTSTR lpType, LPCTSTR lpName, ENUMRESLANGPROC lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId);
  BOOL                         EnumResourceNames(                       HMODULE hModule, LPCTSTR lpszType, ENUMRESNAMEPROC lpEnumFunc, LONG_PTR lParam);
  BOOL                         EnumResourceNamesEx(                     HMODULE hModule, LPCTSTR lpszType, ENUMRESNAMEPROC lpEnumFunc, LONG_PTR lParam, WINAPI_ResourceEnumFlags dwFlags, LANGID LangId);
  BOOL                         EnumResourceTypes(                       HMODULE hModule, ENUMRESTYPEPROC lpEnumFunc, LONG_PTR lParam);
  BOOL                         EnumResourceTypesEx(                     HMODULE hModule, ENUMRESTYPEPROC lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId);
  HRSRC                        FindResource(                            HMODULE hModule, LPCTSTR lpName, LPCTSTR lpType);
  HRSRC                        FindResourceEx(                          HMODULE hModule, LPCTSTR lpType, LPCTSTR lpName, WORD wLanguage);
  BOOL                         FreeResource(                            HGLOBAL hglbResource);
  HGLOBAL                      LoadResource(                            HMODULE hModule, HRSRC hResInfo);
  LPVOID                       LockResource(                            HGLOBAL hResData);
  DWORD                        SizeofResource(                          HMODULE hModule, HRSRC hResInfo);
  BOOL                         UpdateResource(                          HANDLE hUpdate, LPCTSTR lpType, LPCTSTR lpName, WORD wLanguage, LPVOID lpData, DWORD cbData);
  int                          CompareString(                           LCID Locale, WINAPI_StringFlags dwCmpFlags, LPCTSTR lpString1, int cchCount1, LPCTSTR lpString2, int cchCount2);
  int                          CompareStringEx(                         LPCWSTR lpLocaleName, WINAPI_StringFlags dwCmpFlags, LPCWSTR lpString1, int cchCount1, LPCWSTR lpString2, int cchCount2, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM lParam);
  BOOL                         GetStringTypeA(                          LCID Locale, WINAPI_CharacterTypeFlag dwInfoType, LPCSTR lpSrcStr, int cchSrc, LPWORD lpCharType);
  BOOL                         GetStringTypeEx(                         LCID Locale, WINAPI_CharacterTypeFlag dwInfoType, LPCTSTR lpSrcStr, int cchSrc, LPWORD lpCharType);
  BOOL                         GetStringTypeW(                          WINAPI_CharacterTypeFlag dwInfoType, LPCWSTR lpSrcStr, int cchSrc, LPWORD lpCharType);
  LPSTR                        lstrcat(                                 LPSTR lpString1, LPSTR lpString2);
  LPTSTR                       lstrcat(                                 LPTSTR lpString1, LPTSTR lpString2);
  int                          lstrcmp(                                 LPCSTR lpString1, LPCSTR lpString2);
  int                          lstrcmp(                                 LPCTSTR lpString1, LPCTSTR lpString2);
  int                          lstrcmpi(                                LPCSTR lpString1, LPCSTR lpString2);
  int                          lstrcmpi(                                LPCTSTR lpString1, LPCTSTR lpString2);
  LPSTR                        lstrcpy(                                 LPSTR lpString1, LPSTR lpString2);
  LPTSTR                       lstrcpy(                                 LPTSTR lpString1, LPTSTR lpString2);
  LPSTR                        lstrcpyn(                                LPSTR lpString1, LPCSTR lpString2, int iMaxLength);
  LPTSTR                       lstrcpyn(                                LPTSTR lpString1, LPCTSTR lpString2, int iMaxLength);
  int                          lstrlen(                                 LPCSTR lpString);
  int                          lstrlen(                                 LPCTSTR lpString);
  PVOID                        AddVectoredContinueHandler(              ULONG FirstHandler, PVECTORED_EXCEPTION_HANDLER VectoredHandler);
  PVOID                        AddVectoredExceptionHandler(             ULONG FirstHandler, PVECTORED_EXCEPTION_HANDLER VectoredHandler);
  ULONG                        RemoveVectoredContinueHandler(           PVOID Handler);
  ULONG                        RemoveVectoredExceptionHandler(          PVOID Handler);
  LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter(             LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
  LONG                         UnhandledExceptionFilter(                EXCEPTION_POINTERS* ExceptionInfo);
  BOOLEAN                      RtlAddFunctionTable(                     PRUNTIME_FUNCTION FunctionTable, DWORD EntryCount, DWORD64 BaseAddress);
  VOID                         RtlCaptureContext(                       PCONTEXT ContextRecord);
  BOOLEAN                      RtlDeleteFunctionTable(                  PRUNTIME_FUNCTION FunctionTable);
  BOOLEAN                      RtlInstallFunctionTableCallback(         DWORD64 TableIdentifier, DWORD64 BaseAddress, DWORD Length, PGET_RUNTIME_FUNCTION_CALLBACK Callback, PVOID Context, PCWSTR OutOfProcessCallbackDll);
  VOID                         RtlRestoreContext(                       PCONTEXT ContextRecord, PEXCEPTION_RECORD ExceptionRecord);
  DWORD                        QueueUserAPC(                            PAPCFUNC pfnAPC, WINAPI_ThreadHandle hThread, ULONG_PTR dwData);
  BOOL                         GetOverlappedResult(                     HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, BOOL bWait);
  VOID                         AcquireSRWLockExclusive(                 PSRWLOCK SRWLock);
  VOID                         AcquireSRWLockShared(                    PSRWLOCK SRWLock);
  VOID                         InitializeConditionVariable(             PCONDITION_VARIABLE ConditionVariable);
  VOID                         InitializeSRWLock(                       PSRWLOCK SRWLock);
  VOID                         ReleaseSRWLockExclusive(                 PSRWLOCK SRWLock);
  VOID                         ReleaseSRWLockShared(                    PSRWLOCK SRWLock);
  BOOL                         SleepConditionVariableCS(                PCONDITION_VARIABLE ConditionVariable, PCRITICAL_SECTION CriticalSection, WINAPI_WaitTimeout dwMilliseconds);
  BOOL                         SleepConditionVariableSRW(               PCONDITION_VARIABLE ConditionVariable, PSRWLOCK SRWLock, WINAPI_WaitTimeout dwMilliseconds, ULONG Flags);
  BOOLEAN                      TryAcquireSRWLockExclusive(              PSRWLOCK SRWLock);
  BOOLEAN                      TryAcquireSRWLockShared(                 PSRWLOCK SRWLock);
  VOID                         WakeAllConditionVariable(                PCONDITION_VARIABLE ConditionVariable);
  VOID                         WakeConditionVariable(                   PCONDITION_VARIABLE ConditionVariable);
  void                         DeleteCriticalSection(                   LPCRITICAL_SECTION lpCriticalSection);
  void                         EnterCriticalSection(                    LPCRITICAL_SECTION lpCriticalSection);
  void                         InitializeCriticalSection(               LPCRITICAL_SECTION lpCriticalSection);
  BOOL                         InitializeCriticalSectionAndSpinCount(   LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount);
  BOOL                         InitializeCriticalSectionEx(             LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount, DWORD Flags);
  void                         LeaveCriticalSection(                    LPCRITICAL_SECTION lpCriticalSection);
  DWORD                        SetCriticalSectionSpinCount(             LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount);
  BOOL                         TryEnterCriticalSection(                 LPCRITICAL_SECTION lpCriticalSection);
  HANDLE                       CreateEvent(                             LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCTSTR lpName);
  HANDLE                       CreateEventEx(                           LPSECURITY_ATTRIBUTES lpEventAttributes, LPCTSTR lpName, DWORD dwFlags, WINAPI_EventAccessRights dwDesiredAccess);
  HANDLE                       OpenEvent(                               WINAPI_EventAccessRights dwDesiredAccess, BOOL bInheritHandle, LPCTSTR lpName);
  BOOL                         PulseEvent(                              HANDLE hEvent);
  BOOL                         ResetEvent(                              HANDLE hEvent);
  BOOL                         SetEvent(                                HANDLE hEvent);
  BOOL                         InitOnceBeginInitialize(                 LPINIT_ONCE lpInitOnce, DWORD dwFlags, PBOOL fPending, LPVOID* lpContext);
  BOOL                         InitOnceComplete(                        LPINIT_ONCE lpInitOnce, DWORD dwFlags, LPVOID lpContext);
  BOOL                         InitOnceExecuteOnce(                     PINIT_ONCE InitOnce, PINIT_ONCE_FN InitFn, PVOID Parameter, LPVOID* Context);
  VOID                         InitOnceInitialize(                      PINIT_ONCE InitOnce);
  LONG                         InterlockedCompareExchange(              LONG volatile* Destination, LONG Exchange, LONG Comparand);
  LONGLONG                     InterlockedCompareExchange64(            LONGLONG volatile* Destination, LONGLONG Exchange, LONGLONG Comparand);
  LONG                         InterlockedDecrement(                    LONG volatile* Addend);
  LONG                         InterlockedExchange(                     LONG volatile* Target, LONG Value);
  LONG                         InterlockedExchangeAdd(                  LONG volatile* Addend, LONG Value);
  LONG                         InterlockedIncrement(                    LONG volatile* Addend);
  HANDLE                       CreateMutex(                             LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCTSTR lpName);
  HANDLE                       CreateMutexEx(                           LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCTSTR lpName, DWORD dwFlags, WINAPI_MutexAccessRights dwDesiredAccess);
  HANDLE                       OpenMutex(                               WINAPI_MutexAccessRights dwDesiredAccess, BOOL bInheritHandle, LPCTSTR lpName);
  BOOL                         ReleaseMutex(                            HANDLE hMutex);
  BOOL                         AddSIDToBoundaryDescriptor(              HANDLE* BoundaryDescriptor, PSID RequiredSid);
  BOOLEAN                      ClosePrivateNamespace(                   HANDLE Handle, WINAPI_PrivateNamespaceFlag Flags);
  HANDLE                       CreateBoundaryDescriptor(                LPCTSTR Name, ULONG Flags);
  HANDLE                       CreatePrivateNamespace(                  LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes, LPVOID lpBoundaryDescriptor, LPCTSTR lpAliasPrefix);
  VOID                         DeleteBoundaryDescriptor(                HANDLE BoundaryDescriptor);
  HANDLE                       OpenPrivateNamespace(                    LPVOID lpBoundaryDescriptor, LPCTSTR lpAliasPrefix);
  HANDLE                       CreateSemaphore(                         LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCTSTR lpName);
  HANDLE                       CreateSemaphoreEx(                       LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCTSTR lpName, DWORD dwFlags, WINAPI_SemaphoreAccessRights dwDesiredAccess);
  HANDLE                       OpenSemaphore(                           WINAPI_SemaphoreAccessRights dwDesiredAccess, BOOL bInheritHandle, LPCTSTR lpName);
  BOOL                         ReleaseSemaphore(                        HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount);
  void                         InitializeSListHead(                     PSLIST_HEADER ListHead);
  PSLIST_ENTRY                 InterlockedFlushSList(                   PSLIST_HEADER ListHead);
  PSLIST_ENTRY                 InterlockedPopEntrySList(                PSLIST_HEADER ListHead);
  PSLIST_ENTRY                 InterlockedPushEntrySList(               PSLIST_HEADER ListHead, PSLIST_ENTRY ListEntry);
  USHORT                       QueryDepthSList(                         PSLIST_HEADER ListHead);
  BOOL                         ChangeTimerQueueTimer(                   HANDLE TimerQueue, HANDLE Timer, ULONG DueTime, ULONG Period);
  HANDLE                       CreateTimerQueue(                        );
  BOOL                         CreateTimerQueueTimer(                   PHANDLE phNewTimer, HANDLE TimerQueue, WAITORTIMERCALLBACK Callback, PVOID Parameter, DWORD DueTime, DWORD Period, WINAPI_WorkItemFlags Flags);
  BOOL                         DeleteTimerQueue(                        HANDLE TimerQueue);
  BOOL                         DeleteTimerQueueEx(                      HANDLE TimerQueue, HANDLE CompletionEvent);
  BOOL                         DeleteTimerQueueTimer(                   HANDLE TimerQueue, HANDLE Timer, HANDLE CompletionEvent);
  BOOL                         RegisterWaitForSingleObject(             PHANDLE phNewWaitObject, HANDLE hObject, WAITORTIMERCALLBACK Callback, PVOID Context, WINAPI_WaitTimeout dwMilliseconds, WINAPI_WorkItemFlags dwFlags);
  DWORD                        SignalObjectAndWait(                     HANDLE hObjectToSignal, HANDLE hObjectToWaitOn, WINAPI_WaitTimeout dwMilliseconds, BOOL bAlertable);
  BOOL                         UnregisterWait(                          HANDLE WaitHandle);
  BOOL                         UnregisterWaitEx(                        HANDLE WaitHandle, HANDLE CompletionEvent);
  WINAPI_WAIT_RESULT           WaitForMultipleObjects(                  DWORD nCount, HANDLE* lpHandles, BOOL bWaitAll, WINAPI_WaitTimeout dwMilliseconds);
  WINAPI_WAIT_RESULT           WaitForMultipleObjectsEx(                DWORD nCount, HANDLE* lpHandles, BOOL bWaitAll, WINAPI_WaitTimeout dwMilliseconds, BOOL bAlertable);
  WINAPI_WAIT_RESULT           WaitForSingleObject(                     HANDLE hHandle, WINAPI_WaitTimeout dwMilliseconds);
  WINAPI_WAIT_RESULT           WaitForSingleObjectEx(                   HANDLE hHandle, WINAPI_WaitTimeout dwMilliseconds, BOOL bAlertable);
  BOOL                         CancelWaitableTimer(                     HANDLE hTimer);
  HANDLE                       CreateWaitableTimer(                     LPSECURITY_ATTRIBUTES lpTimerAttributes, BOOL bManualReset, LPCTSTR lpTimerName);
  HANDLE                       CreateWaitableTimerEx(                   LPSECURITY_ATTRIBUTES lpTimerAttributes, LPCTSTR lpTimerName, DWORD dwFlags, WINAPI_TimerAccessRights dwDesiredAccess);
  HANDLE                       OpenWaitableTimer(                       WINAPI_TimerAccessRights dwDesiredAccess, BOOL bInheritHandle, LPCTSTR lpTimerName);
  BOOL                         SetWaitableTimer(                        HANDLE hTimer, LARGE_INTEGER* pDueTime, LONG lPeriod, PTIMERAPCROUTINE pfnCompletionRoutine, LPVOID lpArgToCompletionRoutine, BOOL fResume);
  BOOL                         SetWaitableTimerEx(                      HANDLE hTimer, LARGE_INTEGER* lpDueTime, LONG lPeriod, PTIMERAPCROUTINE pfnCompletionRoutine, LPVOID lpArgToCompletionRoutine, PREASON_CONTEXT WakeContext, ULONG TolerableDelay);
  BOOL                         DnsHostnameToComputerName(               LPCTSTR Hostname, LPTSTR ComputerName, LPDWORD nSize);
  UINT                         EnumSystemFirmwareTables(                DWORD FirmwareTableProviderSignature, PVOID pFirmwareTableBuffer, DWORD BufferSize);
  DWORD                        ExpandEnvironmentStrings(                LPCTSTR lpSrc, LPTSTR lpDst, DWORD nSize);
  BOOL                         GetComputerName(                         LPTSTR lpBuffer, LPDWORD lpnSize);
  BOOL                         GetComputerNameEx(                       COMPUTER_NAME_FORMAT NameType, LPTSTR lpBuffer, LPDWORD lpnSize);
  DWORD                        GetFirmwareEnvironmentVariable(          LPCTSTR lpName, LPCTSTR lpGuid, PVOID pBuffer, DWORD nSize);
  void                         GetNativeSystemInfo(                     LPSYSTEM_INFO lpSystemInfo);
  BOOL                         GetProductInfo(                          DWORD dwOSMajorVersion, DWORD dwOSMinorVersion, DWORD dwSpMajorVersion, DWORD dwSpMinorVersion, WINAPI_ProductType* pdwReturnedProductType);
  UINT                         GetSystemDirectory(                      LPTSTR lpBuffer, UINT uSize);
  UINT                         GetSystemFirmwareTable(                  DWORD FirmwareTableProviderSignature, DWORD FirmwareTableID, PVOID pFirmwareTableBuffer, DWORD BufferSize);
  void                         GetSystemInfo(                           LPSYSTEM_INFO lpSystemInfo);
  BOOL                         GetSystemRegistryQuota(                  PDWORD pdwQuotaAllowed, PDWORD pdwQuotaUsed);
  UINT                         GetSystemWindowsDirectory(               LPTSTR lpBuffer, UINT uSize);
  UINT                         GetSystemWow64Directory(                 LPTSTR lpBuffer, UINT uSize);
  DWORD                        GetVersion(                              );
  BOOL                         GetVersionEx(                            LPOSVERSIONINFO lpVersionInfo);
  UINT                         GetWindowsDirectory(                     LPTSTR lpBuffer, UINT uSize);
  BOOL                         IsProcessorFeaturePresent(               WINAPI_ProcessorFeatureEnum ProcessorFeature);
  BOOL                         SetComputerName(                         LPCTSTR lpComputerName);
  BOOL                         SetComputerNameEx(                       COMPUTER_NAME_FORMAT NameType, LPCTSTR lpBuffer);
  BOOL                         SetFirmwareEnvironmentVariable(          LPCTSTR lpName, LPCTSTR lpGuid, PVOID pBuffer, DWORD nSize);
  BOOL                         VerifyVersionInfo(                       LPOSVERSIONINFOEX lpVersionInfo, WINAPI_NtVerType dwTypeMask, DWORDLONG dwlConditionMask);
  ULONGLONG                    VerSetConditionMask(                     ULONGLONG dwlConditionMask, WINAPI_NtVerType dwTypeBitMask, WINAPI_VerOperator dwConditionMask);
  BOOL                         BackupRead(                              HANDLE hFile, LPBYTE lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, BOOL bAbort, BOOL bProcessSecurity, LPVOID* lpContext);
  BOOL                         BackupSeek(                              HANDLE hFile, DWORD dwLowBytesToSeek, DWORD dwHighBytesToSeek, LPDWORD lpdwLowByteSeeked, LPDWORD lpdwHighByteSeeked, LPVOID* lpContext);
  BOOL                         BackupWrite(                             HANDLE hFile, LPBYTE lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, BOOL bAbort, BOOL bProcessSecurity, LPVOID* lpContext);
  DWORD                        CreateTapePartition(                     HANDLE hDevice, DWORD dwPartitionMethod, DWORD dwCount, DWORD dwSize);
  DWORD                        EraseTape(                               HANDLE hDevice, DWORD dwEraseType, BOOL bImmediate);
  DWORD                        GetTapeParameters(                       HANDLE hDevice, DWORD dwOperation, LPDWORD lpdwSize, LPVOID lpTapeInformation);
  DWORD                        GetTapePosition(                         HANDLE hDevice, DWORD dwPositionType, LPDWORD lpdwPartition, LPDWORD lpdwOffsetLow, LPDWORD lpdwOffsetHigh);
  DWORD                        GetTapeStatus(                           HANDLE hDevice);
  DWORD                        PrepareTape(                             HANDLE hDevice, DWORD dwOperation, BOOL bImmediate);
  DWORD                        SetTapeParameters(                       HANDLE hDevice, DWORD dwOperation, LPVOID lpTapeInformation);
  DWORD                        SetTapePosition(                         HANDLE hDevice, DWORD dwPositionMethod, DWORD dwPartition, DWORD dwOffsetLow, DWORD dwOffsetHigh, BOOL bImmediate);
  DWORD                        WriteTapemark(                           HANDLE hDevice, DWORD dwTapemarkType, DWORD dwTapemarkCount, BOOL bImmediate);
  BOOL                         ProcessIdToSessionId(                    DWORD dwProcessId, DWORD* pSessionId);
  DWORD                        WTSGetActiveConsoleSessionId(            );
  void                         GetSystemTime(                           LPSYSTEMTIME lpSystemTime);
  BOOL                         GetSystemTimeAdjustment(                 PDWORD lpTimeAdjustment, PDWORD lpTimeIncrement, PBOOL lpTimeAdjustmentDisabled);
  BOOL                         SetSystemTime(                           SYSTEMTIME* lpSystemTime);
  BOOL                         SetSystemTimeAdjustment(                 DWORD dwTimeAdjustment, BOOL bTimeAdjustmentDisabled);
  BOOL                         FileTimeToLocalFileTime(                 FILETIME* lpFileTime, LPFILETIME lpLocalFileTime);
  DWORD                        GetDynamicTimeZoneInformation(           PDYNAMIC_TIME_ZONE_INFORMATION pTimeZoneInformation);
  void                         GetLocalTime(                            LPSYSTEMTIME lpSystemTime);
  DWORD                        GetTimeZoneInformation(                  LPTIME_ZONE_INFORMATION lpTimeZoneInformation);
  BOOL                         GetTimeZoneInformationForYear(           USHORT wYear, PDYNAMIC_TIME_ZONE_INFORMATION pdtzi, LPTIME_ZONE_INFORMATION ptzi);
  BOOL                         SetDynamicTimeZoneInformation(           DYNAMIC_TIME_ZONE_INFORMATION* lpTimeZoneInformation);
  BOOL                         SetLocalTime(                            SYSTEMTIME* lpSystemTime);
  BOOL                         SetTimeZoneInformation(                  TIME_ZONE_INFORMATION* lpTimeZoneInformation);
  BOOL                         SystemTimeToTzSpecificLocalTime(         LPTIME_ZONE_INFORMATION lpTimeZone, LPSYSTEMTIME lpUniversalTime, LPSYSTEMTIME lpLocalTime);
  BOOL                         TzSpecificLocalTimeToSystemTime(         LPTIME_ZONE_INFORMATION lpTimeZoneInformation, LPSYSTEMTIME lpLocalTime, LPSYSTEMTIME lpUniversalTime);
  LONG                         CompareFileTime(                         FILETIME* lpFileTime1, FILETIME* lpFileTime2);
  BOOL                         FileTimeToSystemTime(                    FILETIME* lpFileTime, LPSYSTEMTIME lpSystemTime);
  BOOL                         GetFileTime(                             HANDLE hFile, LPFILETIME lpCreationTime, LPFILETIME lpLastAccessTime, LPFILETIME lpLastWriteTime);
  void                         GetSystemTimeAsFileTime(                 LPFILETIME lpSystemTimeAsFileTime);
  BOOL                         LocalFileTimeToFileTime(                 FILETIME* lpLocalFileTime, LPFILETIME lpFileTime);
  BOOL                         SetFileTime(                             HANDLE hFile, FILETIME* lpCreationTime, FILETIME* lpLastAccessTime, FILETIME* lpLastWriteTime);
  BOOL                         SystemTimeToFileTime(                    SYSTEMTIME* lpSystemTime, LPFILETIME lpFileTime);
  BOOL                         DosDateTimeToFileTime(                   WORD wFatDate, WORD wFatTime, LPFILETIME lpFileTime);
  BOOL                         FileTimeToDosDateTime(                   FILETIME* lpFileTime, LPWORD lpFatDate, LPWORD lpFatTime);
  BOOL                         GetSystemTimes(                          LPFILETIME lpIdleTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime);
  DWORD                        GetTickCount(                            );
  ULONGLONG                    GetTickCount64(                          );
  BOOL                         QueryPerformanceCounter(                 LARGE_INTEGER* lpPerformanceCount);
  BOOL                         QueryPerformanceFrequency(               LARGE_INTEGER* lpFrequency);
  BOOL                         IsDBCSLeadByte(                          BYTE TestChar);
  BOOL                         IsDBCSLeadByteEx(                        WINAPI_CodePageEnum CodePage, BYTE TestChar);
  int                          MultiByteToWideChar(                     WINAPI_CodePageEnum CodePage, WINAPI_MultiByteFlags dwFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
  int                          WideCharToMultiByte(                     WINAPI_CodePageEnum CodePage, WINAPI_WideCharFlags dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar);
  DWORD                        VerLanguageName(                         DWORD wLang, LPTSTR szLang, DWORD cchLang);
  VOID                         RaiseFailFastException(                  PEXCEPTION_RECORD pExceptionRecord, PCONTEXT pContextRecord, DWORD dwFlags);
  HRESULT                      WerGetFlags(                             WINAPI_ProcessHandle hProcess, PDWORD pdwFlags);
  HRESULT                      WerRegisterFile(                         PCWSTR pwzFile, WER_REGISTER_FILE_TYPE regFileType, WINAPI_WerFileFlags dwFlags);
  HRESULT                      WerRegisterMemoryBlock(                  PVOID pvAddress, DWORD dwSize);
  HRESULT                      WerRegisterRuntimeExceptionModule(       PCWSTR pwszOutOfProcessCallbackDll, PVOID pContext);
  HRESULT                      WerSetFlags(                             DWORD dwFlags);
  HRESULT                      WerUnregisterFile(                       PCWSTR pwzFilePath);
  HRESULT                      WerUnregisterMemoryBlock(                PVOID pvAddress);
  HRESULT                      WerUnregisterRuntimeExceptionModule(     PCWSTR pwszOutOfProcessCallbackDll, PVOID pContext);
  BOOL                         CreateDirectory(                         LPCTSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
  BOOL                         CreateDirectoryEx(                       LPCTSTR lpTemplateDirectory, LPCTSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
  BOOL                         CreateDirectoryTransacted(               LPCTSTR lpTemplateDirectory, LPCTSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction);
  BOOL                         FindCloseChangeNotification(             HANDLE hChangeHandle);
  HANDLE                       FindFirstChangeNotification(             LPCTSTR lpPathName, BOOL bWatchSubtree, WINAPI_FILE_NOTIFY_CHANGE_FLAGS dwNotifyFilter);
  BOOL                         FindNextChangeNotification(              HANDLE hChangeHandle);
  DWORD                        GetCurrentDirectory(                     DWORD nBufferLength, LPTSTR lpBuffer);
  BOOL                         ReadDirectoryChangesW(                   HANDLE hDirectory, LPVOID lpBuffer, DWORD nBufferLength, BOOL bWatchSubtree, WINAPI_FILE_NOTIFY_CHANGE_FLAGS dwNotifyFilter, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);
  BOOL                         RemoveDirectory(                         LPCTSTR lpPathName);
  BOOL                         RemoveDirectoryTransacted(               LPCTSTR lpPathName, HANDLE hTransaction);
  BOOL                         SetCurrentDirectory(                     LPCTSTR lpPathName);
  BOOL                         GetDiskFreeSpace(                        LPCTSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters);
  BOOL                         GetDiskFreeSpaceEx(                      LPCTSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailable, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes);
  BOOL                         DefineDosDevice(                         WINAPI_DDD_FLAGS dwFlags, LPCTSTR lpDeviceName, LPCTSTR lpTargetPath);
  BOOL                         DeleteVolumeMountPoint(                  LPCTSTR lpszVolumeMountPoint);
  HANDLE                       FindFirstVolume(                         LPTSTR lpszVolumeName, DWORD cchBufferLength);
  BOOL                         FindNextVolume(                          HANDLE hFindVolume, LPTSTR lpszVolumeName, DWORD cchBufferLength);
  BOOL                         FindNextVolumeMountPoint(                HANDLE hFindVolumeMountPoint, LPTSTR lpszVolumeMountPoint, DWORD cchBufferLength);
  BOOL                         FindVolumeClose(                         HANDLE hFindVolume);
  BOOL                         FindVolumeMountPointClose(               HANDLE hFindVolumeMountPoint);
  WINAPI_DRIVE_TYPE            GetDriveType(                            LPCTSTR lpRootPathName);
  DWORD                        GetLogicalDrives(                        );
  DWORD                        GetLogicalDriveStrings(                  DWORD nBufferLength, LPTSTR lpBuffer);
  BOOL                         GetVolumeInformation(                    LPCTSTR lpRootPathName, LPTSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, WINAPI_LPFILE_SYSTEM_FLAGS lpFileSystemFlags, LPTSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize);
  BOOL                         GetVolumeInformationByHandleW(           HANDLE hFile, LPTSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, WINAPI_LPFILE_SYSTEM_FLAGS lpFileSystemFlags, LPTSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize);
  BOOL                         GetVolumeNameForVolumeMountPoint(        LPCTSTR lpszVolumeMountPoint, LPTSTR lpszVolumeName, DWORD cchBufferLength);
  BOOL                         GetVolumePathName(                       LPCTSTR lpszFileName, LPTSTR lpszVolumePathName, DWORD cchBufferLength);
  BOOL                         GetVolumePathNamesForVolumeName(         LPCTSTR lpszVolumeName, LPTSTR lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength);
  DWORD                        QueryDosDevice(                          LPCTSTR lpDeviceName, LPTSTR lpTargetPath, DWORD ucchMax);
  BOOL                         SetVolumeLabel(                          LPCTSTR lpRootPathName, LPCTSTR lpVolumeName);
  HANDLE                       FindFirstVolumeMountPoint(               LPTSTR lpszRootPathName, LPTSTR lpszVolumeMountPoint, DWORD cchBufferLength);
  BOOL                         SetVolumeMountPoint(                     LPCTSTR lpszVolumeMountPoint, LPCTSTR lpszVolumeName);
  BOOL                         CreatePipe(                              PHANDLE hReadPipe, PHANDLE hWritePipe, LPSECURITY_ATTRIBUTES lpPipeAttributes, DWORD nSize);
  BOOL                         CallNamedPipe(                           LPCTSTR lpNamedPipeName, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, WINAPI_NMPWAIT nTimeOut);
  BOOL                         ConnectNamedPipe(                        HANDLE hNamedPipe, LPOVERLAPPED lpOverlapped);
  HANDLE                       CreateNamedPipe(                         LPCTSTR lpName, WINAPI_PIPE_ACCESS dwOpenMode, WINAPI_PIPE_MODE dwPipeMode, DWORD nMaxInstances, DWORD nOutBufferSize, DWORD nInBufferSize, DWORD nDefaultTimeOut, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
  BOOL                         DisconnectNamedPipe(                     HANDLE hNamedPipe);
  BOOL                         GetNamedPipeClientComputerName(          HANDLE Pipe, LPTSTR ClientComputerName, ULONG ClientComputerNameLength);
  BOOL                         GetNamedPipeClientProcessId(             HANDLE Pipe, PULONG ClientProcessId);
  BOOL                         GetNamedPipeClientSessionId(             HANDLE Pipe, PULONG ClientSessionId);
  BOOL                         GetNamedPipeHandleState(                 HANDLE hNamedPipe, WINAPI_PIPE_STATE* lpState, LPDWORD lpCurInstances, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout, LPTSTR lpUserName, DWORD nMaxUserNameSize);
  BOOL                         GetNamedPipeInfo(                        HANDLE hNamedPipe, WINAPI_PIPE_TYPE* lpFlags, LPDWORD lpOutBufferSize, LPDWORD lpInBufferSize, LPDWORD lpMaxInstances);
  BOOL                         GetNamedPipeServerProcessId(             HANDLE Pipe, PULONG ServerProcessId);
  BOOL                         GetNamedPipeServerSessionId(             HANDLE Pipe, PULONG ServerSessionId);
  BOOL                         PeekNamedPipe(                           HANDLE hNamedPipe, LPVOID lpBuffer, DWORD nBufferSize, LPDWORD lpBytesRead, LPDWORD lpTotalBytesAvail, LPDWORD lpBytesLeftThisMessage);
  BOOL                         SetNamedPipeHandleState(                 HANDLE hNamedPipe, WINAPI_PIPE_MODE* lpMode, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout);
  BOOL                         TransactNamedPipe(                       HANDLE hNamedPipe, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, LPOVERLAPPED lpOverlapped);
  BOOL                         WaitNamedPipe(                           LPCTSTR lpNamedPipeName, WINAPI_NMPWAIT nTimeOut);
  DWORD                        DisableThreadProfiling(                  HANDLE PerformanceDataHandle);
  DWORD                        EnableThreadProfiling(                   HANDLE ThreadHandle, DWORD Flags, DWORD64 HardwareCounters, HANDLE PerformanceDataHandle);
  DWORD                        QueryThreadProfiling(                    HANDLE ThreadHandle, PBOOLEAN Enabled);
  DWORD                        ReadThreadProfilingData(                 HANDLE PerformanceDataHandle, DWORD Flags, PPERFORMANCE_DATA PerformanceData);
  LARGE_INTEGER*               BaseFormatTimeOut(                       LARGE_INTEGER* pLITimeout, DWORD dwMillis);
  NTSTATUS                     BaseGetNamedObjectDirectory(             HANDLE* phDir);
  BOOL                         Basep8BitStringToDynamicUnicodeString(   PUNICODE_STRING pConvertedStr, LPCSTR pszAnsiStr);
  DWORD                        CheckElevationEnabled(                   BOOL* pResult);
  BOOL                         SetConsoleCursor(                        HANDLE hConsole, HCURSOR hCursor);
  BOOL                         SetConsoleMaximumWindowSize(             HANDLE hConsole, DWORD dwUnk);
  BOOL                         SetStdHandleEx(                          WINAPI_StdHandle dwStdHandle, HANDLE hNewHandle, HANDLE* phOldHandle);
  int                          ShowConsoleCursor(                       HANDLE hConsoleOutput, BOOL bShow);
  DWORD                        AddLocalAlternateComputerName(           LPCTSTR lpDnsFQHostname, ULONG ulFlags);
  FARPROC                      DelayLoadFailureHook(                    LPCSTR pszDllName, LPCSTR pszProcName);
  PVOID                        DecodePointer(                           PVOID Ptr);
  PVOID                        DecodeSystemPointer(                     PVOID Ptr);
  PVOID                        EncodePointer(                           PVOID Ptr);
  PVOID                        EncodeSystemPointer(                     PVOID Ptr);
  int                          MulDiv(                                  int nNumber, int nNumerator, int nDenominator);
]]
return ffi.load( "Kernel32.dll" )
